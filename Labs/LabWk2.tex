\documentclass{lab}

\usepackage{graphicx}
\usepackage{float}
\usepackage{soul}
\usepackage{multicol}

\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}

\title{ENGG1003 - Lab 2 (And Beyond)}
\author{Brenton Schulz}
\date{\today}

\begin{document}
\maketitle

\section{Feedback}

To help me write better labs please fill out this survey when you leave your \textbf{Week 2} lab:
\vspace{5mm} \\ 
\huge{\underline{\href{https://docs.google.com/forms/d/1wUgJlZGRcYm7_ZKBOxzc3DHkZv5UVqKQJ_EGQhSV55Q/}{Click here to complete the survey before you leave.}}}\\
\vspace{2mm}
\normalsize

I just want to know how many problems the ``average'' student can complete in 3 hours. It will also tell me which problems are more engaging than others (does everyone \textit{hate} probability? Do you love it? I have no idea.)

You likely won't be able to complete \textit{all} the problems, that is intentional. If 60\% of you complete the lab it means I don't know how many questions 60\% can do in 3hrs.

\section{Introduction}

This set of programming exercises leaves you to perform a series of tasks on your own. This can be daunting at first, but your ability to remain resolute and resourceful in an atmosphere of extreme pessimism\footnote{Yes, this is a reference to the computer game \textit{Portal} (2007).} will be a useful skill when studying Engineering\footnote{Talk to your demonstrators about how true this is. I write it only partially in jest. I've found it a necessary skill for \textit{life}.}. (In truth, I hope you don't find it \textit{that} hard and gain satisfaction and confidence from getting programs to work).

The example tasks are mostly ``toy'' programs. They don't do anything particularly useful because most ``real-world'' problems are too advanced for this stage of the course. Things will get more interesting in the coming weeks (I hope...).

Do not expect programs to compile (let alone \textit{work}) first go. It is totally normal, even for experienced programmers, for multiple lines of hand typed code to generate several errors the first time compilation is attempted. You will then find \textit{more} errors when they are executed and found to produce the wrong output.

In time you will learn to interpret and deal with error messages quickly. Typically they will be a syntax error due to a missing parenthesis, semicolon, or double quote. Don't be afraid to ask for help from demonstrators and work with other students in the lab.

In short: all of your time spent programming will be fixing problems because as soon as all the (known) problems are fixed you stop programming and ship the software to your customer.

Generally speaking, the development process follows repeated application of the following steps:

\begin{enumerate}
\item Make a code change
\item Compile
\item Fix compile errors, repeat until code compiles
\item Test program with known correct input-output data
\item Repeat whole process until correct output is generated for multiple test inputs
\end{enumerate}

I don't know how long these problems will take you to complete. With some adjustments, this may become a problem set for weeks 2 and 3.

\pagebreak
\section{Pseudocode to C Conversion Examples}

Pseudocode is any rough working out which you write (or are given) which describes a computer algorithm in the most human-readable form practical. It will \textit{not} run when typed into a C compiler. It only exists to document algorithms and assist in helping you convert a ``real world'' problem into computer code.

The table below covers the flow control structures seen so far. The first entry is what I consider to be the \textit{absolute minimum} required for all code in this course. The \texttt{main()} function is required, it is where program execution begins.

\begin{table}[H]
\centering
\begin{tabular}{ll}
Pseudocode & C Code \\
\hline
\begin{lstlisting}[style=pseudo]
BEGIN
	// do things
END
\end{lstlisting}&

\begin{lstlisting}[style=Ctable]
#include <stdio.h>
int main() {
	// do things
	return 0;
}
\end{lstlisting}\\
\hline

\begin{lstlisting}[style=pseudo]
IF condition
	// do things
ENDIF
\end{lstlisting}&

\begin{lstlisting}[style=Ctable]
if(condition) {
	// do things
}
\end{lstlisting}\\
\hline

\begin{lstlisting}[style=pseudo]
IF condition
	// do things
ELSE
	// do things
ENDIF
\end{lstlisting}&

\begin{lstlisting}[style=Ctable]
if(condition) {
	// do things
} else {
	// do things
}
\end{lstlisting}\\
\hline

\begin{lstlisting}[style=pseudo]
IF condition
	// do things
ELSE IF condition
	// do things
ELSE
	// do things
ENDIF
\end{lstlisting}&

\begin{lstlisting}[style=Ctable]
if(condition) {
	// do things
} else if(condition) {
	// do things
} else {
	// do things
}
\end{lstlisting}\\
\hline

\begin{lstlisting}[style=pseudo]
WHILE condition
	// do things
ENDWHILE
\end{lstlisting}&

\begin{lstlisting}[style=Ctable]
while(condition) {
	// do things
}
\end{lstlisting}\\
\hline

\end{tabular}
\end{table}

\pagebreak
\section{Data Type Subset and Format Specifiers}

Although C contains many data types you only need to consider the following subset when completing this lab:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
Type &  Value Range   & Format Specifier         \\
\hline
\texttt{int}         & -2 147 483 647 to +2 147 483 647 & \texttt{\%d}\\
\texttt{float}   & $1.2\times 10^{-38}$ to $3.4 \times 10^{38}$ & \texttt{\%f}   \\
\hline
\end{tabular}
\end{table}

The \textit{Value Range} indicates the maximum and minimum values which can be stored in each type. For the  \texttt{float} data type both positive and negative numbers can be stored. If an arithmetic statement causes an \texttt{int} to exceed the value range the result will ``wrap around''; a behaviour known as \textit{overflow} or \textit{underflow}. If you type in a number which is too big and read it with \texttt{scanf("\%d", \&x);} the number stored will be different to that which you typed in.

The \textit{format specifier} is the text which goes inside \texttt{scanf();} and \texttt{printf();} when reading or printing numbers, respectively. It tells the compiler how ASCII text should be converted into a number (and back again).

Eg, to read and print an \texttt{int}:

\begin{lstlisting}[style=CStyle]
int value;
scanf("%d", &value);
printf("You entered: %d\n", value);
\end{lstlisting}

Change the two \texttt{\%d}'s to \texttt{\%f} to read and print a \texttt{float}. Always consider what data type is being read or written when typing format specifiers.

If you write the wrong format specifier it will result in garbage. For example, the following code uses \texttt{\%f} inside \texttt{scanf();} when it should have been \texttt{\%d}:

\begin{lstlisting}[style=CStyle]
#include <stdio.h>

int main() {
	int x;
	printf("Enter an integer: ");
	scanf("%f", &x); // %f is incorrect!
	printf("You entered: %d\n", x); 
	return 0;
}
\end{lstlisting}

It exhibits the following behaviour on when executed:

\begin{lstlisting}[style=pseudo]
Enter an integer: 1
You entered: 1065353216
\end{lstlisting}

The compiler, gcc, produces a \textit{warning} when the code is compiled:

\begin{lstlisting}[style=CStyle]
format.c: In function ‘main’:
format.c:6:10: warning: format ‘%f’ expects argument of type ‘float *’, but argument 2 has type ‘int *’ [-Wformat=]
  scanf("%f", &x);
         ~^   ~~
         %d
\end{lstlisting}

but, unfortunately, OnlineGDB does not show it to you. It only displays warnings if errors also occurred. We will be moving to a more advanced development environment which \textit{does} print warnings as soon as IT has made it work on the lab machines.


\pagebreak
\section{Usage of \texttt{printf();} and \texttt{scanf();}}

The basic usage of \texttt{printf();} and \texttt{scanf();} when working with single integers is:

\begin{lstlisting}[style=CStyle]
scanf("%d", &x); // Read an integer, store it in x
printf("%d \n", x); // Print the value of x followed by a new line
\end{lstlisting}

If using \texttt{float} or \texttt{double} ``fractional'' numbers the \texttt{\%d} gets replaced with \texttt{\%f}.

They can, however, be used to read or print arbitrarily many variables. To do this you:

\begin{enumerate}
\item Use multiple format specifiers (\texttt{\%d} and \texttt{\%f}) inside the \textit{format string}
\item List multiple variables, separated by commas, after the format string
\end{enumerate}

The format string is everything between the pair of double quotes:
\begin{lstlisting}[style=CStyle]
printf("This is the format string.\n")
\end{lstlisting}
For example, to read three integers, \texttt{x, y,} and \texttt{z} from the console:

\begin{lstlisting}[style=CStyle]
int x,y,z; // This declares three int variables on one line
scanf("%d %d %d", &x, &y, &z);
\end{lstlisting}

The integers you type need to be separated by spaces (note that spaces are present inside the format string) and \texttt{$<$enter$>$} typed to end the line. The \texttt{scanf();} function won't process any data until an end of line is read.

Note that the order is \textit{crucial}; the numbers you type will go into \texttt{x, y} and \texttt{z} in the the same order that the variable names are listed in \texttt{scanf();}.

You don't \textit{need} to separate the input with spaces. You can, for example, read an hh:mm time with:

\begin{lstlisting}[style=CStyle]
scanf("%d:%d", &hours, &minutes);
\end{lstlisting}

and \texttt{scanf();} will match the integer-colon-integer pattern with the input and extract hours and minutes.

\texttt{scanf();} even supports incredibly advanced ``pattern matching'' but it is \textit{well} beyond the scope of ENGG1003.

Note that the numbers don't all need to be integers. You can mix integers and, say, \texttt{double}s:

\begin{lstlisting}[style=CStyle]
int x,y; // This declares three int variables on one line
double z;
scanf("%d %d %f", &x, &y, &z);
\end{lstlisting}

Likewise, the \texttt{printf();} function can print multiple numbers in arbitrary locations. You can write a mixture of \texttt{\%d} and \texttt{\%f} anywhere inside the format string and values will be pulled from the list of variables in order.

For example:

\begin{lstlisting}[style=CStyle]
int a = 1, b = 2;
float c = 1.23;
double d = 8.2;
printf("%d is an integer, %d is an integer, have some more numbers: %f %f\n", a, b, c, d);
\end{lstlisting}

will print:

\texttt{1 is an integer, 2 is an integer, have some more numbers: 1.23 8.2}

Lastly, if you get this compiler warning:


\texttt{main.c:6:13: warning: format ‘\%d’ expects argument of type ‘int *’, but argument 3 has type ‘float *’ [-Wformat=]
  scanf("\%d:\%d", \&h, \&m);}


it means that the data type and format specifier don't match. You have made a mistake, fix it.

\pagebreak
\section{Getting Started Questions}

These problems are \textit{not} meant to be executed in a C compiler. Read through them and write your answers on paper (or Word etc). Solutions can be found on the last page of this document.

\begin{enumerate}
\item What are the values of \texttt{x, y, v,} and \texttt{z} after execution of each line? On which lines are each variable undeclared (ie: their value is known)? You don't need to run this code, only read and think about it.
\begin{lstlisting}[style=CStyle]
int x = 2;
int y, v, r;
float z;
x = x+5;
y = 2*x + 3;
v = y/x; // NB: integer division
r = y%x;
z = (float)y/x; // Forced to floating point division
\end{lstlisting}
\item What is printed to the console if the user enters \texttt{13$<$enter$>$}? You don't need to run this code, only read and think about it.
\begin{lstlisting}[style=CStyle]
float k;
printf("Enter a number: ")
scanf("%f", &k);
k = 1.43*k + 84;
printf("%f\n", k);
printf("%d\n", (int)k); // Integer truncation
\end{lstlisting}
\item Write a \texttt{printf();} statement which takes an integer variable \texttt{temp} and prints:

\texttt{The temperature reading of $<$temp$>$ is dangerous}

to the screen (with \texttt{$<$temp$>$} replaced with the actual value, ie: write the \%d format specifier in that spot).
\item A variable is required which stores integers with a maximum possible value of ten billion. What C data type is required? Why can't you use an \texttt{int}? See Section \ref{sec:datatypes} for a list of C data types.
\item A variable is required to store a real number with 10 significant figures. What C data type is required? See Section \ref{sec:datatypes} for a list of C data types.
\item Write a C ``code snippet'' which implements the following pseudocode (decrement implies a subtraction by 1):
\begin{lstlisting}[style=pseudo]
IF x is not equal to zero
	decrement x
ENDIF
\end{lstlisting}

A ``code snippet'' is just the code required to implement the pseudocode, you don't need to write a full program. In this case, you are only converting the pseudocode \texttt{IF..ENDIF} into something that looks like:

\begin{lstlisting}[style=CStyle]
if(condition) {
	/* stuff */ 
}
\end{lstlisting}
 
\item Write a C code snippet which implements the following pseudocode:
\begin{lstlisting}[style=pseudo]
WHILE x is greater than 1
	y = y*x;
	x = x-1;
ENDWHILE
\end{lstlisting}
\pagebreak
\item Write a C code snippet which implements the following pseudocode:
\begin{lstlisting}[style=pseudo]
BEGIN
	integer result
	integer x
	READ x from the console
	IF x is zero
		result = -1
	ELSEIF x is -1
		result = 0
	ELSE
		result = 1
	ENDIF
END
\end{lstlisting}
\end{enumerate}




\pagebreak
\section{Input-Processing-Output Exercises}

These exercises all require the use of \texttt{scanf();} to read data, some arithmetic to process data, and \texttt{printf();} to print results to the console.

Every task requires the following steps:

\begin{enumerate}
\item Work out what variables are required
\item What \textit{type} do the variables need to be?
\item Convert an equation to C code. Do we need to be careful with data types?
\item Write a \texttt{scanf();} statement to read the user's input
\item Write a \texttt{printf();} statement to print the result
\item (Optional) Do you want the user to be \textit{prompted}? This is when text appears in the console telling the user what to enter. This requires a \texttt{printf();} prior to the \texttt{scanf();}
\item (Optional) Does the output need to be in a human sentence? Write the \texttt{printf();} statement.
\item (Optional) Should you limit the precision of the printed result? Are 6 decimal places appropriate? Should it only be 1? Use the \texttt{\%.nf} format specifier to limit floating point precision to \texttt{n} decimal places
\end{enumerate}

The following template can be used for all these exercises:

\begin{lstlisting}[style=CStyle]
#include <stdio.h>

int main() {
	// Declare the required variables 
	// eg: int x; float y; etc	
	
	// Get input from the user
	// eg: 	printf("Enter a number: ");
	// 		scanf("%f", &y);	
	
	// Do the calculation
	// x = ....whatever
	
	// Print result to user
	// eg: Printf("%d times %d is %d\n", x, y, z);
		
	return 0;
}
\end{lstlisting}

\pagebreak
\subsection{Example}
Write a C program which calculates a miles to kilometres conversion with the following formula:
\begin{equation}
\texttt{km} = 1.60934 \times \texttt{miles}.
\end{equation}

Going through the steps above:
\begin{enumerate}
\item We need a variable \texttt{miles} and another \texttt{km}
\item We are multiplying by a fractional number so they need to be of type \texttt{float} (or \texttt{double})
\item In C, the equation is implemented with: \texttt{km = 1.60934 * miles;}
\item To read a \texttt{float} from the user we need the \texttt{\%f} format specifier in \texttt{scanf();}. To store the read value in \texttt{miles}, we can use: \texttt{scanf("\%f", \&miles);}
\item To print the result of type \texttt{float} we need the \texttt{\%f} format specifier, so we can print it with:\\ \texttt{printf("\%f\textbackslash n", km);}
\end{enumerate}

To make the above ``code snippets'' \textit{actually run} they need to be written inside \texttt{main() \{ \}} and we need to write \texttt{\#include $<$stdio.h$>$} at the top. Putting it all together, the following code will implement the problem:

\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int main() {
	float km;
	float miles;
	
	scanf("%f", &miles);
	km = 1.60934 * miles;
	printf("%f\n", km);
	
	return 0;
}
\end{lstlisting}

All the Tasks in this section can be implemented by modifying the above template.

\pagebreak
\subsection{Tasks}
\begin{task}{Temperature Conversion}{}
The formula for converting temperatures in Farenheit, $F$ to Celsius, $C$, is:

\begin{equation}\label{eq:temp}
C = \frac{5}{9}(F - 32).
\end{equation}

Given the C template, write a program which performs this conversion. It should read the Farenheit temperature from \texttt{stdin} and print the result to \texttt{stdout}. The program should correctly handle any practical real values (eg: 19.38) as input. Print the result to 2 decimal places.
\\ \\
Test your code with several values calculated with \underline{\href{https://www.google.com.au/search?q=farenheit+to+celsius}{Google}}.
\end{task}

\begin{task}{Variance Calculation}{}
From statistics, the \textit{sample variance}, $s^2$, of $N$ samples, $X_1, X_2, ... , X_N$, can be calculated as:

\begin{equation}\label{eq:var}
s^2 = \frac{1}{N-1}\sum_{k=1}^{N}(X_k - mean(X))^2.
\end{equation}

Write a C program which reads \textbf{four} numbers and outputs their sample variance.
\\ \\
Given that $N = 4$ (and some algebra) Equation \ref{eq:var} can be expanded into two steps:

\begin{enumerate}
\item Calculate the sample mean: $\texttt{mean} = \frac{1}{4} \times \left( X_1 + X_2 + X_3 + X_4 \right)$
\item Calculate the variance: $\texttt{var} = \frac{1}{3} \times ((X_1-\texttt{mean})^2 + (X_2-\texttt{mean})^2 + (X_3-\texttt{mean})^2 + (X_4-\texttt{mean})^2)$
\end{enumerate}

Your program will have to declare four \texttt{float} variables to store the four input values. To read four numbers in one instance of \texttt{scanf();} you can do this:

\begin{lstlisting}[style=CStyle]
float x1, x2, x3, x4;
scanf("%f %f %f %f", &x1, &x2, &x3, &x4);
\end{lstlisting}

Test your program given that the variance of the set (1, 2, 3, 4) = 1.6667
\\ \\
\textbf{NB 1:} Be careful with the $\frac{1}{4}$ and $\frac{1}{3}$ constants in the equations above. They may experience integer division problems. If in doubt, convert them to floating point literals.
\\ \\
\textbf{Observation:} Did you find programming this task is really tedious? What if you had 100 samples? Or a million? In later weeks we will learn about \textit{arrays}. These are a C language feature which greatly simplify the code when you need to keep track of a lot of data.
\end{task}

\begin{task}{Linear Interpolation}{}
There are many instances in science and engineering when data needs to be \textit{interpolated}. Informally, this is the process of predicting a quantity's value somewhere between two (or more) data points.
\\ \\
In this task you will be using the \textit{two-point formula} (you saw this in high school, right?) to interpolate between two data points. You can imagine these data points to be measurements of temperature / brightness / sound intensity / pressure / etc as a function of time.\\ \\
The two-point formula states that the equation of a line passing through two points $(x_1, y_1)$ and $(x_2, y_2)$ is:
\begin{equation}
y = \frac{y_2 - y_1}{x_2 - x_1}(x - x_1) + y_1.
\end{equation}
The value of $y$ at some given $x$ can then be estimated. For the purposes of interpolation $x$ will always be in between the given data points. ie, assuming $x_2 > x_1$:
\begin{equation}
x_2 > x > x_1.
\end{equation}
Note that $y$ is only an \textit{estimate} of the true value. You will often see this notated as $\hat{y}$, especially in statistics.
\\ \\
The process of estimating values outside the $[x_1, x_2]$ interval is known as \textit{extrapolation}\footnote{\url{https://xkcd.com/605/}} and is beyond the scope of this task.
\\ \\
Given the above, write a C program which implements the following pseudocode:
\begin{lstlisting}[style=CStyle]
BEGIN
	READ x1 and y1 from the console
	READ x2 and y2 from the console
	READ a point x from the console
	Estimate the value of y at x using linear interpolation
	PRINT y
END
\end{lstlisting}
To understand this problem you will find it useful to draw some sketches. Draw an x-y axis, dot two points and draw a line between them. If you pick two neat integer points (eg: 0,0 and 5,5) then the linear interpolation will be easy to see by eye. Perform several tests with known-correct sets of values to confirm that your code is correct.
\\ \\
Program implementation notes:
\begin{itemize}[itemsep=1mm]
\item Reading a pair of points can be done with:
\begin{lstlisting}[style=CStyle]
float x1, y1;
printf("Enter point 1: ");
scanf("%f %f", &x1, &y1);
\end{lstlisting}
you would then type two numbers into the console, separated by a space, and press enter.
\item Keep all variables as \texttt{float} or \texttt{double}. It doesn't \textit{really} matter which, just be consistent.
\end{itemize}
\end{task}

\pagebreak
\section{Flow Control Exercises}

A template is not explicitly provided for these tasks. You can, however, use the "hello world" template provided by OnlineGDB or the code written for previous tasks as a starting point.

This first task presents you with all the required building blocks to implement a simple algorithm. All this program will do is read in 2 integers, perform a division, then print the result. A check is performed to make sure a division by zero does not occur.

\begin{task}{}{}
Write a program which implements the following pseudocode:

\begin{lstlisting}[style=pseudo]
BEGIN 
	integer a 
	integer b
	integer q
	integer r
	Read an integer from standard input, store it in a
	Read an integer from standard input, store it in b
	IF b is zero
		PRINT "Division by zero error"
	ELSE
		q = a/b
		r = a%b
		PRINT "a divided by b is" <the value of q>
		PRINT "and the remainder is" <the value of r>
	ENDIF
END
\end{lstlisting}

Notes:

\begin{itemize}
\item Reading each integer can be done with: \texttt{scanf("\%d", \&a);} (with an appropriate substitution for the variable name). You may prompt the user by placing a \texttt{printf();} \textit{without} newline character prior to \texttt{scanf();}, eg:

\begin{lstlisting}[style=CStyle]
printf("Enter an integer: ");
scanf("%d", &a);
\end{lstlisting}

\item Note that $<$the value of c$>$ in the pseudocode is implying that a number should be printed there, ie:

\begin{lstlisting}[style=CStyle]
printf("a divided by b is %d\n", c);
\end{lstlisting}

\item The condition "b is zero" needs to be implemented with the \texttt{==} (\textit{two} equals symbols) operator.

\item You may start with the default code listing provided by OnlineGDB
\end{itemize}
\end{task}

{\huge\textit{This is where most (approx 77\%) students have gotten up to. Don't feel bad if you're out of time by now.}}

\begin{task}{Calculating Square Roots}{}
The square root of a number, $x = \sqrt{n}$, can be calculated with the iterative formula:
\begin{equation}\label{eq:sqrt}
x_{k+1} = \frac{1}{2}\left(x_k + \frac{n}{x_k}\right)
\end{equation}
\textbf{Task:} Write a C program which implement this formula to calculate square roots of real numbers. The value of $n$ is to be read from the console with \texttt{scanf();} and the result printed with \texttt{printf();}.
\\ \\
The choice of $x_0$ is somewhat arbitrary, the algorithm should \textit{converge} ($x_n$ will move towards the result, not away) given any sane value (eg: not infinity), but will converge \texttt{faster} (ie: in fewer iterations) if $x_0$ is closer to the true value of $\sqrt{n}$. You may play with this value and observe how accurate the result is after a fixed number of iterations (say, 5). Common choices for $x_0$ would be $x_0 = n$ or $x_0 = 1$.
\\ \\
The algorithm will require a loop. The exit condition could be one of several choices. In order of difficulty:
\begin{enumerate}
\item Exit after a fixed number of iterations (eg: 10)
\item Exit when $\left| x_k - x_{k-1} \right| < e$ where $e$ is some pre-defined precision of your choosing
\item Exit when either of the above conditions are met
\end{enumerate}

To calculate precision you will need to explicitly save $x_k$ and $x_{k-1}$ in different variables.
\\ \\
\textbf{Sketch out pseudocode (either on \textit{actual dead tree paper} or in Word/text editor/in code comments) before attempting to write the C program.}
\\ \\
\textbf{Hint:} You can place \texttt{printf();} statements inside the loop to help you debug. Calculate the series of $x_n$'s for a particular value (eg: $\sqrt{2}=1.4142$) by hand (with the same value for $x_0$) so that you can compare your program's output with an output you have confidence in.
\end{task}\label{tsk:sqrt}

\pagebreak
\subsection{Else-If}

The C syntax for an \texttt{IF .. ELSEIF .. ENDIF} flow control structure is:

\begin{lstlisting}[style=CStyle]
if( condition ) {
	// Statements
} else if( condition ) {
	// Statements
}
\end{lstlisting}

There are many variants, for more examples see Section \ref{sec:if}.

Please be aware of a common mistake: a semicolon should \textit{not} be placed after an \texttt{if()} statement. Doing so tells the compiler ``if this condition is true, do nothing''. C will always do exactly what you tell it to, even if you tell it to do something that appears to be useless.

\begin{task}{Quadratic Equation Analysis}{}
The Friday Week 1 lecture introduced the following pseudocode for solving quadratic equations:
\begin{lstlisting}[style=pseudo]
BEGIN
	INPUT: a, b, c
	D = b^2 - 4ac
	IF D < 0
		 N = 0
	ELSEIF D == 0
		N = 1
		x1 = -b/(2a)
	ELSEIF D > 0
		N = 2
		x1 = (-b + sqrt(D))/(2a)
		x2 = (-b - sqrt(D))/(2a)
	ENDIF
	OUTPUT: N, x1, x2
END
\end{lstlisting}

\textbf{Everyone:} Write a C program which takes the \texttt{a, b,} and \texttt{c} values and outputs the number of real valued solutions which exist (ie: 0, 1, or 2).
\\ \\
\textbf{Everyone:} Introduce a ``temporary'' variable (ie: short lived, one we stop caring about soon after it is used) which explicitly removes the requirement to calculate \texttt{sqrt(D)} twice.
\\ \\
\textbf{Advanced:} Using the square root algorithm in Equation \ref{eq:sqrt}, implement the full quadratic equation solution algorithm.
\end{task}

\pagebreak
\section{Random Numbers}

The following tasks involve generating and using random numbers. The standard C library (glibc, in Linux and MinGW, provided by the \underline{\href{https://en.wikipedia.org/wiki/GNU_Project}{GNU project}}) contains a function called \texttt{rand();} which creates a random number between 0 and a constant called \texttt{RAND\_MAX}. In glibc \texttt{RAND\_MAX} is 2147483647, or the maximum value an \texttt{int} can store. It may vary between implementations (older systems may use 32767, for example).

Because \texttt{rand();} is part of a ``library'' and not built into the C language you need to include a \textit{header file} which describes to the compiler what \texttt{rand();} is before it is used. To do this, type the following line at the top of your source listing (anywhere above \texttt{main()}):

\begin{lstlisting}[style=CStyle]
#include <stdlib.h>
\end{lstlisting}

The \texttt{rand();} function can then be included in your code. You can write it in all the same places that you would write a variable or literal. All of the following statements are valid:

\begin{lstlisting}[style=CStyle]
x = rand();
y = 10 + rand() % 5;
printf("A random number is: %d\n", rand() );
\end{lstlisting}

Generally you aren't after a random number between 0 and \texttt{RAND\_MAX}. To limit the rand of integers generated we can use the modulus (\texttt{\%}) operator. For the purposes of this course the following methods can be used to generate:

\begin{itemize}
\item A number between 0 and \texttt{MAX}:
\begin{lstlisting}[style=CStyle]
x = rand() % (MAX + 1);
\end{lstlisting}

\item A number between 1 and \texttt{MAX}:
\begin{lstlisting}[style=CStyle]
x = rand() % MAX + 1;
\end{lstlisting}

\item A floating point number between 0 and \texttt{MAX}:
\begin{lstlisting}[style=CStyle]
x = (float)rand()/RAND_MAX * MAX;
\end{lstlisting}
\textbf{NB:} \texttt{rand();} becomes an \texttt{int} so an explicit cast to \texttt{float} (or \texttt{double}) is required to avoid integer division errors.

\end{itemize}

\textbf{IMPORTANT:} The \texttt{rand();} function is what's known as ``pseudo-random''. Repeated use of \texttt{rand();} will generate a sequence of random numbers but the \textit{same sequence} will be generated every time the program is run.

To change the sequence you can use the \texttt{srand();} function (known as ``seed-rand'') with a manually chosen random number:

\begin{lstlisting}[style=CStyle]
srand(233534);
\end{lstlisting}

Every different number given to \texttt{srand();} will cause a different random sequence to be generated by \texttt{rand();}. You only need to include \texttt{srand();} \textbf{once}, somewhere before \texttt{rand();} is used.

In the future, we will learn how to ``seed'' random number generation with the current time. That way the sequence will automatically change each time the program is run.

Example:

\begin{lstlisting}[style=CStyle]
#include <stdio.h>
#include <stdlib.h>
int main() {
	int x;
	srand(2323423);
	x = rand();
	printf("A random number is: %d\n", x);
}

\end{lstlisting}

\begin{task}{Rolling Dice}{}
Using the \texttt{rand();} function, write a C program which estimates the probability that, when two dice are thrown, at least one of the dice rolled a 3. This can be done with the following algorithm:
\begin{lstlisting}[style=pseudo]
BEGIN
	counter = 0;
	aThreeHappened = 0
	WHILE counter < 1000
		a = random number between 1 and 6
		b = random number between 1 and 6
		IF (a == 3) OR (b == 3)
			aThreeHappened = aThreeHappened + 1
		END
		counter = counter + 1
	ENDWHILE
	PRINT aThreehappened / counter
END
\end{lstlisting}

The theoretical value is $\frac{11}{36} = 0.3055$
\end{task}

\begin{task}{Arithmetic Tutor}{}
Write a C program which can be used to teach basic arithmetic to primary school children.
\\ \\
Your program should follow the following algorithm:
\begin{lstlisting}[style=pseudo]
BEGIN
	integer max
	READ max from the user
	integer a = a random number between 1 and max
	integer b = a random number between 1 and max
	integer c = a + b
	PRINT What is a + b? // a and b the numerical values
	READ an integer d
	IF c == d
		PRINT "Correct!"
	ELSE
		PRINT "Wrong :(. The correct answer is " c
	ENDIF
END
\end{lstlisting}
\textbf{Extension 1:} Modify the algorithm so that it keeps generating problems until the user gets one wrong. (ie: Chuck a \texttt{while()} around the appropriate lines, create a variable which records if the answer was wrong or correct, and test that variable in the \texttt{while()} condition).
\\ \\
\textbf{Extension 2:} Add a variable which keeps score and prints the number of correctly answered questions on program exit.
\\ \\
\textbf{Advanced:} Add a menu to the start of the program which allows the user to select between addition, subtraction, multiplication, and division. Implement integer division where the user must enter the result as quotient and remainder.
\end{task}

\begin{task}{Calculating Pi}{}
Implement the $\pi$ calculation algorithm talked about during lectures. The pseudocode is:
\begin{lstlisting}[style=pseudo]
BEGIN
        integer countTotal = 0
        integer countInside = 0
        WHILE countTotal < A large number
                x = random number between 0 and 1
                y = random number between 0 and 1
                countTotal = countTotal + 1
                IF x*x + y*y < 1
                        countInside = countInside + 1
                ENDIF
        ENDWHILE
        pi = 4*countInside/countTotal
        PRINT pi
END
\end{lstlisting}
\textbf{NB:} If running this on OnlineGDB use a ``small'' value for the maximum loop count. Try one million. If this takes longer than around 10 seconds to execute use a smaller value. You are occupying OnlineGDB's shared CPU resources when running this program.
\end{task}

\pagebreak
\section{Mandelbrot Set - Advanced}
\textit{This problem is presented for students interested in mathematics. It may take several lab sessions to correctly implement this task. If you do not understand anything here, do not be troubled. Do not feel the need to attempt this task. The mathematics is beyond the scope of ENGG1003.} \\ \\
\textit{Demonstrators are not to help you solve this problem. It is intended for students who have advanced beyond expectations, doing it alone is part of the challenge.}\\

A complex number, $C$, exists within the \textit{Mandelbrot set} if, when iterated with the formula:

\begin{equation}
z_{n+1} = z^2_n + C,
\end{equation}

with initial condition $z_0 = 0$, the value of $\left|z_n\right|$ stays bounded (ie: doesn't ``blow off to infinity'') as $n$ becomes ``very large''. It's calculation can be used to create \underline{\href{https://www.google.com.au/search?q=mandelbrot+set}{mathematical artwork}}. Hanging in my office is a piece of art known as a \underline{\href{https://www.google.com.au/search?q=buddahbrot}{Buddahbrot}}. Calculation took several days on an R9 270X gaming graphics card. Come check it out some time. I have an unhealthy love of this branch of mathematics.
\\ \\
Purely real examples:
\begin{itemize}
\item $C = 0.1$ is \textit{inside} the Mandelbrot set, as:
\begin{align}
z_1 &= 0 + 0.1 \\
z_2 &= 0.1^2 + 0.1 = 0.11 \\
z_3 &= 0.11^2 + 0.1 = 0.1121 \\
... \\
z_{14} &= 0.112701665^2 + 0.1 = 0.112701665 \\
Z_{15} &= 0.112701665^2 + 0.1 = 0.112701665 
\end{align}
...and it just sits at 0.112701665 forever.
\item $C = 1$ is \textit{outside} the Mandelbrot set, as:
\begin{align}
z_1 &= 0 + 1 \\
z_2 &= 1^2 + 1 = 2 \\
z_3 &= 2^2 + 1 = 5 \\
z_4 &= 5^2 + 1 = 26 \\
z_5 &= 26^2 + 1 = 677 \\
... \\
z_{11} &= (3.79 \times 10^{90})^2 + 1 = 1.4 \times 10^{181}
\end{align}
...and it just keeps getting bigger. Fast.
\end{itemize}

\begin{task}{}{} Write a C program which tests a \textit{single} point, $C$, for inclusion in the Mandelbrot set. This code can be expanded to draw an image in a later lab.
\end{task}

To do this you will be need to know that:
\begin{itemize}[itemsep=0mm]
\item $z$ and $C$ are complex numbers with real and imaginary parts

\item Introducing some notation:
\begin{align}
z_n &= x_n + iy_n \\
C &= x_0 + iy_0
\end{align}
Where $x$ denotes a real part and $y$ the imaginary.
\item Using rules of complex arithmetic it can be shown that:
\begin{align}
z_{n+1} &= z^2_{n} + C \\
&= x^2_n + i2x_ny_n - y^2_n + x_0 + iy_0
\end{align}
\item To evaluate this on a computer which only deals with \textit{real} numbers it has to be split into real and imaginary parts:
\begin{align}
Re(z_{n+1}) = x_{n+1} &= x^2_n - y^2_n + x_0\\
Im(z_{n+1}) = y_{n+1} &= 2x_ny_n + y_0
\end{align}
\item A complex number's norm (or absolute value, informally its ``size'') can be calculated as:
\begin{equation}
\left|z\right| = \sqrt{x^2 + y^2}
\end{equation}
and is needed to test if $z_n$ is getting ``too big''. For this problem, ``too big'' is typically defined as ``outside a circle of radius 2''. To avoid having to calculate the square root (which can be slow) you can take the so-called \textit{escape condition} as:
\begin{equation}
x^2 + y^2 > 4
\end{equation}
In code, this will go inside a loop's exit condition. Either as a ``NOT (x*x+y*y $>$ 4)'' or, more simply, ``x*x + y*y $<$ 4'' as loop conditions need to remain TRUE for the loop to continue.
\item The loop which implements the iterative equation needs to keep track of the iteration count but does \textit{not} need to record a full history of $z_n$'s. You only need the ''next'' and ''current' values of $x_n$ and $y_n$. At some point an assignment causes the ``next'' to become the ``current''.
\item An \textit{iteration limit} needs to be set. A point, $C$, is considered ``inside'' the set if the iteration limit is hit without $\left|z_n\right|$ exceeding $2$.
\item If $\left|z_n\right| > 2$ before the iteration limit is hit the point, $C$, is inside the Mandelbrot set
\item Full, somewhat optimised, pseudocode for this problem can be found on \underline{\href{https://en.wikipedia.org/wiki/Mandelbrot_set}{Wikipedia}}. Independent research may be required to implement this problem.
\item For testing purposes here are some test points with an iteration limit of 1000:
	\begin{itemize}
		\item $C = 0 + i0$ takes 1000 iterations
		\item $C = 0.5 + i0$ takes 5 iterations
		\item $C = 0.4 +i0.1$ takes 8 iterations
		\item $C = 0.38 +i0.1$ takes 36 iterations
		\item $C = -0.38 +i0.1$ takes 1000 iterations
		\item If all these test points take an iteration count which is offset by 1 from my solution your code is probably fine. This kind of error happens all the time due to $<$ Vs $<=$ and the like.
	\end{itemize}
\end{itemize}


\pagebreak 
\section{C Summary}
This section will be included in all future lab documents and lists a summary of C language features taught prior to the lab session. It will grow each week.

Not everything listed in this section is required to complete a particular lab.

\begin{multicols}{2}
\subsection{Basic Structure}
This is the absolute minimum amount of code you need to make a C program compile, run, and interact with the user via a console:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int main() {
	// Your program goes here
	return 0;
}
\end{lstlisting}
\subsection{Comments}
\begin{lstlisting}[style=CStyle]
// This is a comment to end of line

/* this is a block comment
   which could span
   multiple
   lines
   */
\end{lstlisting}

\subsection{Code Blocks}

Any section of code encompassed by \texttt{\{...\}} is a \textit{block}.

\subsection{Operators}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
\hline
Operation      & C Symbol \\
\hline
Addition       & \texttt{+}        \\
Subtraction    & \texttt{-}        \\
Multiplication & \texttt{*}        \\
Division       & \texttt{/}       \\
Modulus		   & \texttt{\%}	\\
Increment	& \texttt{++}	\\
Decrement	& \texttt{--} \\
Less than       & $\texttt{<}$        \\
Less than or equal to    & $\texttt{<=}$\\
Greater than & $\texttt{>}$        \\
Greater than or equal to       & $\texttt{>=}$ \\
Equal to & \texttt{==} \\
Not equal to & \texttt{!=} \\
Boolean AND & \texttt{\&\&} \\
Boolean OR & \texttt{||} \\
Boolean NOT & \texttt{!} \\
\hline
\end{tabular}
\caption{Arithmetic operators in C}
\end{table}

\columnbreak
\subsection{Operator Shorthand}

Many arithmetic operators support the following shorthand syntax. The left and right columns present equivalent statements.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\texttt{x = x + y;} & \texttt{x += y;} \\
\texttt{x = x - y;} & \texttt{x -= y;} \\
\texttt{x = x * y;} & \texttt{x *= y;} \\
\texttt{x = x / y;} & \texttt{x /= y;} \\
\hline
\end{tabular}
\end{table}

\subsection{Data Types}\label{sec:datatypes}

\begin{table}[H]
\begin{tabular}{|l|l|l|l|}
\hline
Type & Bytes & Value Range                             \\
\hline
\texttt{char}      & 1                  & -128, +127  \\
\texttt{unsigned char}	& 1				& 0, 255 \\
\texttt{short}     & 2                & -32768, 32767\\
\texttt{unsigned short} & 2			& 0, 65535 \\
\texttt{int}       & 4                & $\approx \pm 2.1\times 10^9$ \\
\texttt{unsigned int}	& 4				& 0, 4294967296 \\
\texttt{long}      & 8                  & $\approx \pm 9.2\times 10^{18}$ \\
\texttt{unsigned long} & 8				& 0, $1.8 \times 10^{19}$ \\
\texttt{float}       & 4  & $1.2\times 10^{-38}$ to $3.4 \times 10^{38}$    \\
\texttt{double}      & 8  & $2.3 \times 10^{-308}$ to $1.7 \times 10^{308}$    \\

\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
Type & Precision \\
\hline
\texttt{float} & 6 sig. figs. \\
\texttt{double} & 15 sig. figs \\
\hline
\end{tabular}
\end{table}


\subsection{Standard i/o}

Read a single variable from \texttt{stdin} with \texttt{scanf();}
\texttt{scanf("\textit{format specifier}", \&\textit{variable}});

Write a single variable to \texttt{stdout} with \texttt{printf();}
\texttt{printf("\textit{format specifier}", \textit{variable});}

You can use \texttt{printf();} \textit{without} a newline (\texttt{\textbackslash n}) to create an input prompt:

\begin{lstlisting}[style=CStyle]
printf("Enter a number: ");
scanf("%d", &variable);
\end{lstlisting}

This prints:

\texttt{Enter a number: \_}

where \_ indicates the terminal prompt (ie: where typed characters will appear).

\subsection{Format Specifiers}
The following table is woefully incomplete. The compiler \textit{may} generate warnings if \texttt{\%d} is given something other than \texttt{int} and \texttt{\%f} is given something other than \texttt{float}. An attempt will be made to ensure these are sufficient.
\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
Data Type & Format Specifier \\
\hline
Integers & \texttt{\%d} \\
Floating point & \texttt{\%f} \\
Float with \texttt{n} decimal places & \texttt{\%.nf} \\
\hline
\end{tabular}
\caption{Basic format specifiers}
\end{table}

\subsection{Type Casting}
Placing the syntax \texttt{(\textit{type})} before a variable name performs a type cast (ie: data type conversion).

eg: convert \texttt{float} to an \texttt{int} prior to using its value. This forces a rounding-down to the nearest integer.

\begin{lstlisting}[style=CStyle]
float a;
// ...
y = (int)a * z;
\end{lstlisting}

\textbf{NB:} This does \textbf{not} modify the original variable.

Data type ``upgrades'' are done automatically by the compiler but sometimes it is desired to downgrade or force esoteric behaviour. Adding it unnecessarily doesn't have any negative impact. Applications in ENGG1003 will be limited but it comes up regularly in embedded systems and nobody else explicitly teaches type casting. I have used it extensively in the low-level art of \textit{bit banging}: manual manipulation of binary data. This is, unfortunately, beyond ENGG1003.

\subsection{Flow control}

Flow control allows selected blocks of code to execute multiple times or only under a specified condition.

\subsubsection{\texttt{if()}}\label{sec:if}

The \texttt{if()} statement executes a block of code only if the \textit{condition} is true. The condition is an arithmetic statement which evaluates to either zero (false) or non-zero (true).

\texttt{if()} Syntax:

\texttt{if(\textit{condition}) \{/* other code */\}}

\columnbreak
Full \texttt{if()} example:

\begin{lstlisting}[style=CStyle]
if(x > 10) {
	// Do stuff
}
\end{lstlisting}

Condition Examples:
\begin{itemize}
\item \texttt{if(x) // if(x is not zero)}
\item \texttt{if(x+y) //if((x+y) is not zero)}
\item \texttt{if(y >= 5)}
\item \texttt{if(1) // Always executes}
\item \texttt{if(0) // Never executes}
	\begin{itemize}
		\item Can be used for debugging. Might be easier than a block comment /* */
	\end{itemize}
\end{itemize}

\textbf{NB:} \textit{NEVER} place a semicolon after an \texttt{if()}, that stops it from having any effect. The block after it will always execute. This bug can take days to find.

If there is only \textit{one} statement after an \texttt{if()} the \{ \} braces are optional:

\begin{lstlisting}[style=CStyle]
if(x > 10) 
	printf("x is greater than 10\n");
\end{lstlisting}


\subsubsection{\texttt{if() ... else if()}}

The C syntax for IF ... ELSE is:

\begin{lstlisting}[style=CStyle]
if(condition) {
	// Do stuff
} else {
	// Do stuff
}
\end{lstlisting}

IF ... ELSEIF takes the form:

\begin{lstlisting}[style=CStyle]
if(condition) {
	// Do stuff
} else if(condition) {
	// Do stuff
}
\end{lstlisting}

Multiple ``layers'' of \texttt{else if()} can be written. You don't have to stop at two.

\textbf{NB:} \textit{NEVER} place a semicolon directly after  the \texttt{else if()}. Semicolons only go after the statements inside the \texttt{if()} block (ie: between the curly braces \{ \}).

\columnbreak
\subsubsection{\texttt{while()}}

The \texttt{while()} flow control statement executes a block of code so long as a condition is true. The condition is checked before the block is executed and before every repeated execution.

The condition rules and examples are the same as for those listed under the \texttt{if()} statement.

Syntax:

\texttt{while(\textit{condition)} \{/* other code */\}}

Example:

Evaluate the infinite sum:
\begin{equation}
\sum_{n=0}^{\infty} \frac{1}{n^2}
\end{equation}
to a precision of $1 \times 10^{-6}$
\begin{lstlisting}[style=CStyle]
float sum = 0.0;
int x = 0;
while(1/(x*x) > 1e-6) {
	sum = sum + 1.0/(x*x);
	x++
}
\end{lstlisting}

\textbf{NB:} \textit{NEVER} place a semicolon directly after a \texttt{while()} line. Semicolons only go after the statements inside the loop.

\subsubsection{\texttt{for(;;)}}

\textit{As of week 2 this has not yet been covered in lectures.}

The \texttt{for(;;)} loop syntax is:

\begin{lstlisting}[style=CStyle]
for( initial ; condition ; increment ) {
	// Do stuff
}
\end{lstlisting}

The three sub-parts have the following behaviour:

\begin{itemize}
\item \textbf{Initial:} Code which is executed \textit{once}, before the loop is entered
\item \textbf{Condition:} A condition which is tested \textit{before} every loop iteration
\item \textbf{Increment:} Code which is executed \textit{after} every iteration
\end{itemize}

\texttt{for(;;)} Example:

\begin{lstlisting}[style=CStyle]
int x;
for( x = 0 ; x < 10 ; x++ ) {
	printf("%d ", x);
}
\end{lstlisting}

will print:

\texttt{0 1 2 3 4 5 6 7 8 9}

The \texttt{for(;;)} loop example doesn't print \texttt{10} because the condition is ``strictly less than 10''. When x is incremented to 10 the condition fails and the loop exits. It prints 0 because the increment is only applied \textit{after} the loop has run once.


\subsection{Library Functions}
\subsubsection{\texttt{rand()}}

To generate a random number between \texttt{0} and \texttt{MAX}:

\begin{lstlisting}[style=CStyle]
#include <stdlib.h> // For rand()
// ...
x = rand() % (MAX + 1);
\end{lstlisting}

For all work in this course you may assume that the above method works well enough.

For more crucial work (eg: cryptography, serious mathematics) this method is considered problematic. Very advanced discussion \underline{\href{http://www.azillionmonkeys.com/qed/random.html}{Here}}.

\subsection{Glossary of Terms}

\textit{I'll sort these alphabetically later, just a brain dump for now. Sorry.}

\begin{itemize}
\item \textbf{Compiler:} The software package which converts \textit{source code} into a \textit{binary}.
\item \textbf{Source Code:} The text which you type into a programming environment (eg: OnlineGDB) which is sent to the \textit{compiler}.
\item \textbf{Binary:} A program data file which can be executed on a computer.
\item \textbf{Variable:} A ``thing'' which remembers a number within your program. In C they have a \textit{type}, a name, (optionally) an initial value, and (for future reference) a \textit{memory address}. Variables change when they are on the left side of an \textit{assignment}.
\item \textbf{Pseudocode:} Any hand-written or typed notes which document the behaviour of a computer program. Pseudocode is for humans to read, not computers.
\item \textbf{Flow Control:} Any algorithmic statement which breaks the ``top-to-bottom, line-by-line'' execution pattern of a computer program.
\columnbreak
\item \textbf{Statement:} A line of C code which performs a task and ends with a semicolon. Arithmetic lines, \texttt{printf();}, \texttt{scanf();}, and \texttt{rand();} are all examples of statements.
\item \textbf{Assignment:} The process of changing a variable's value as your program executes. In C, this is typically performed with the \texttt{=} symbol. Eg: \texttt{x = y + 5} calculates the value of ``\texttt{y + 5}'' then allocates the result to the variable \texttt{x}.
\item \textbf{Block:} A section of code ``grouped together'' by curly braces \{ ... \}. Typically applies to flow control, where a single, say, \texttt{if()} controls a block of code listed inside \{ and \}.
\item \textbf{Literal:} Any numerical constant written in your code. Eg: In \texttt{x < 2.0} the ``\texttt{2.0}'' is a literal. Unless otherwise stated, integer literals are treated as \texttt{int} data types (ie: they inherit the \texttt{int}'s value range limit) and real valued literals are treated as \texttt{double}s.
\end{itemize}

\end{multicols}

\pagebreak
\section{Getting Started Question Solutions}
\begin{enumerate}
\item What are the values of \texttt{x, y, v,} and \texttt{z} execution of each line? On which lines are each variable undeclared (ie: their value is known)?
\begin{lstlisting}[style=CStyle]
int x = 2;	// x = 2, all others unknown
int y, v, r;// x = 2, y v r still unknown
float z;		// x = 2, y v r z still unknown
x = x+5;		// x = 7
y = 2*x + 3;// y = 17
v = y/x; 	// NB: integer division.  v = 2
r = y%x;		// r = remainder of (17 / 7) = 3
z = (float)y/x; // Forced to floating point division, z = 2.4286
\end{lstlisting}
\item What is printed to the console if the user enters \texttt{13$<$enter$>$}?
\begin{lstlisting}[style=CStyle]
float k;
printf("Enter a number: ")
scanf("%f", &k);
k = 1.43*k + 84;		//k = 1.43*13+84 = 102.59
printf("%f\n", k);	// 102.590000 (6 decimal places by default)
printf("%d\n", (int)k); // Integer truncation, prints: "102"
\end{lstlisting}
\item Write a \texttt{printf();} statement which takes an integer variable \texttt{temp} and prints:

\texttt{The temperature reading of 123 is dangerous}

to the screen (with 123 replaced with the actual value).

\begin{lstlisting}[style=CStyle]
// Question didn't specify if a new line is needed. Consider the trailing \n optional
printf("The temperature reading of %d is dangerous", temp);
\end{lstlisting}

\item A variable is required which stores integers with a maximum possible value of ten billion. What C data type is required?

\texttt{long}. An \texttt{int} only stores up to approx 2.1 billion so it can't be used. Some C documentation claims that \texttt{long} is the same size as \texttt{int}. On some systems that is true, but not for the systems you are compiling on. OnlineGDB (and, later, Eclipse Che) are running on 64-bit machines on which \texttt{long} is an 8-byte data type consistent with the table in Section \ref{sec:datatypes}.

\item A variable is required to store a real number with 10 significant figures. What C data type is required?

\texttt{double}. A \texttt{float} only has about 6 significant figures of precision

\item Write a C code snippet which implements the following pseudocode (decrement implies a subtraction by 1):
\begin{lstlisting}[style=pseudo]
IF x is not equal to zero
	decrement x
ENDIF
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
if(x != 0)
{
	x--; // --x will also work. As would x = x - 1 or x -= 1
}
 \end{lstlisting}
 
\item Write a C code snippet which implements the following pseudocode:
\begin{lstlisting}[style=pseudo]
WHILE x is greater than 1
	y = y*x;
	x = x-1;
ENDWHILE
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
while(x > 1) {
	y = y * x;
	x = x - 1;
} // end while()
\end{lstlisting}

\item Write a C code snippet which implements the following pseudocode:
\begin{lstlisting}[style=pseudo]
BEGIN
	integer result
	integer x
	READ x from the console
	IF x is zero
		result = -1
	ELSEIF x is -1
		result = 0
	ELSE
		result = 1
	ENDIF
END
\end{lstlisting}
\begin{lstlisting}[style=CStyle]
int result;
int x
scanf("%d", &x);
if(x == 0) {
	result = -1;
} else if(x == -1) {
	result = 0;
} else {
	result = 1;
}
\end{lstlisting}

\end{enumerate}

\end{document}
