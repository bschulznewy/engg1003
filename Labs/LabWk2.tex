\documentclass{lab}

\usepackage{graphicx}
\usepackage{float}
\usepackage{soul}
\usepackage{multicol}

\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}

\title{ENGG1003 - Lab 2}
\author{Brenton Schulz}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

This lab leaves you to perform a series of programming exercises on your own. This can be daunting at first but confidence and perseverance will be crucial skills.

The example tasks are mostly ``toy'' programs. They don't do anything particularly useful because most ``real-world'' problems are too advanced for this stage of the course. Things will get more interesting in the coming weeks (I hope...).

Do not expect programs to compile (let alone \textit{work}) first go. It is totally normal, even for experienced programmers, for several lines of hand typed code to generate several errors the first time it is compiled.

You will gain experience interpreting the error messages, typically it will be a syntax error due to a missing parenthesis, semicolon, or double quote. Don't be afraid to ask for help and work with other students in the lab.

\section{Input-Processing-Output Exercises}

These exercises all require the use of \texttt{scanf();} to read data, some arithmetic to process data, and \texttt{printf();} to print results to the console.

Every task requires the following steps:

\begin{enumerate}
\item Work out what variables are required
\item What \textit{type} do the variables need to be?
\item Convert an equation to C code. Do we need to be careful with data types?
\item Write a \texttt{scanf();} statement to read the user's input
\item Write a \texttt{printf();} statement to print the result
\item (Optional) Do you want the user to be \textit{prompted}? This is when text appears in the console telling the user what to enter. This requires a \texttt{printf();} prior to the \texttt{scanf();}
\item (Optional) Does the output need to be in a human sentence? Write the \texttt{printf();} statement.
\item (Optional) Should you limit the precision of the printed result? Are 6 decimal places appropriate? Should it only be 1?
\end{enumerate}

The following template can be used for all these exercises:

\begin{lstlisting}[style=CStyle]
#include <stdio.h>

int main() {
	// Declare the required variables 
	
	// Get input from the user
	
	// Do the calculation
	
	// Print result to user
	
	return 0;
}
\end{lstlisting}

\begin{task}{Temperature Conversion}{}
The formula for converting temperatures in Farenheit, $F$ to Celsius, $C$, is:

\begin{equation}\label{eq:temp}
C = \frac{5}{9}(F - 32)
\end{equation}

Given the C template, write a program which performs this conversion. It should read the Farenheit temperature from \texttt{stdin} and print the result to \texttt{stdout}. The program should correctly handle any practical real values (eg: 19.38) input. Print the result to 2 decimal places.
\\ \\
Test your code with several values calculated with \underline{\href{https://www.google.com.au/search?q=farenheit+to+celsius}{Google}}.
\end{task}

\begin{task}{Variance Calculation}{}
From statistics, the \textit{sample variance}, $s^2$, of $N$ samples can be calculated as:

\begin{equation}\label{eq:var}
s^2 = \frac{\sum_{k=1}^{N}(X_k - mean(X))}{N-1}.
\end{equation}

Write a C program which reads \textbf{four} numbers and outputs their sample variance.
\\ \\
Given that $N = 4$ (and some algebra) Equation \ref{eq:var} can be expanded into two steps:

\begin{enumerate}
\item Calculate the sample mean: $\texttt{mean} = \frac{1}{4} \times \left( X_1 + X_2 + X_3 + X_4 \right)$
\item Calculate the variance: $\texttt{var} = \frac{1}{3} \times ((X_1 + X_2 + X_3 + X_4 - 4 \times \texttt{mean})$
\end{enumerate}

Your program will have to declare four \texttt{float} variables to store the four input values. To read four numbers in one instance of \texttt{scanf();} you can do this:

\begin{lstlisting}[style=CStyle]
float x1, x2, x3, x4;
scanf("%f %f %f %f", &x1, &x2, &x3, &x4);
\end{lstlisting}

Test your program given that the variance of the set (1, 2, 3, 4) = 1.6667
\\ \\
\textbf{NB:} Be careful with the $\frac{1}{4}$ and $\frac{1}{3}$ constants in the equations above. They may experience integer division problems.

\end{task}

\pagebreak
\section{Flow Control Exercises}

This first task presents you with all the required building blocks to implement a simple algorithm. All this program will do is read in 2 integers, perform a division, then print the result. A check is performed to make sure a division by zero does not occur.

\begin{task}{}{}
Write a program which implements the following pseudocode:

\begin{lstlisting}[style=pseudo]
BEGIN 
	Integer a 
	Integer b
	Integer c
	Read an integer from standard input, store in a
	Read an integer from standard input, store in b
	IF b is zero
		PRINT "Division by zero error"
		RETURN // stop executing
	ENDIF
	c = a/b
	PRINT "a divided by b is" <the value of c>
END
\end{lstlisting}

Notes:

\begin{itemize}
\item Reading each integer can be done with: \texttt{scanf("\%d", \&a);} (with an appropriate substitution for the variable name). You may prompt the user by placing a \texttt{printf();} \textit{without} newline character prior to \texttt{scanf();}, eg:

\begin{lstlisting}[style=CStyle]
printf("Enter an integer: ");
scanf("%d", &a);
\end{lstlisting}

\item Note that $<$the value of c$>$ in the pseudocode is implying that a number should be printed there, ie:

\begin{lstlisting}[style=CStyle]
printf("a divided by b is %d\n", c);
\end{lstlisting}


\item The \texttt{RETURN} pseudocode can be implemented with:
\begin{lstlisting}[style=CStyle]
return 0;
\end{lstlisting}

\item The condition "b is zero" needs to be implemented with the \texttt{==} (\textit{two} equals symbols) operator.

\item You may start with the default code listing provided by OnlineGDB
\end{itemize}
\end{task}

\begin{task}{Square Root Evaluation}{}
The square root of a number, $x = \sqrt{n}$, can be calculated with the iterative formula:
\begin{equation}
x_{k+1} = \frac{1}{2}\left(x_k + \frac{n}{x_k}\right)
\end{equation}
Implement an algorithm which uses this formula to calculate square roots of real numbers. The value of $n$ is to be read from the console with \texttt{scanf();} and the result printed with \texttt{printf();}.
\\ \\
The choice of $x_0$ is somewhat arbitrary, the algorithm should converge given any sane value (ie: not infinity), but will converge faster if $x_0$ is closer to the true value of $\sqrt{n}$. You may play with this value and observe any differences. Common choices would be setting it to $n$ or zero.
\\ \\
The algorithm will require a loop. The exit condition could be one of several choices. In order of difficulty:
\begin{enumerate}
\item Exit after a fixed number of iterations (eg: 10)
\item Exit when $\left| x_k - x_{k-1} \right| < e$ where $e$ is some pre-defined precision
\item Exit when either of the above conditions are met
\end{enumerate}

To calculate precision you will need to explicitly save $x_k$ and $x_{k-1}$ in different variables.
\\ \\
\textbf{Hint:} You can place \texttt{printf();} statements inside the loop to help you debug. Calculate a particular value (eg: $\sqrt{2}$) by hand with a known $x_0$ so that you can compare your program's output with a known correct output.
\end{task}

\begin{task}{Quadratic Equation Analysis}{}
The Friday Week 1 lecture introduced the following pseudocode for solving quadratic equations:
\begin{lstlisting}[style=pseudo]
BEGIN
	INPUT: a, b, c
	D = b^2 - 4ac
	IF D < 0
		 N = 0
	ELSEIF D = 0
		N = 1
		x1 = -b/(2a)
	ELSEIF D > 0
		N = 2
		x1 = (-b + sqrt(D))/(2a)
		x2 = (-b - sqrt(D))/(2a)
	ENDIF
	OUTPUT: N, x1, x2
END
\end{lstlisting}

\textbf{Everyone:} Write a C program which takes the \texttt{a, b,} and \texttt{c} values and outputs the number of real valued solutions which exist (ie: 0, 1, or 2).
\\ \\
\textbf{Advanced:} Using the square root algorithm coded previously, implement the full quadratic equation solution algorithm.
\end{task}

\begin{task}{Mandelbrot Set - Advanced}{}
\textit{This problem is presented for students interested in mathematics. It may take several lab sessions to correctly implement this task. If you do not understand anything here, do not be troubled. The mathematics is beyond the scope of ENGG1003.} \\ \\

The \textit{Mandelbrot set} is the set of all complex numbers, $C$, which can be iterated with the formula:

\begin{equation}
z_{n+1} = z^2 + C
\end{equation}

and initial condition $z_0 = 0$ and have the value of $z_n$ stay bounded (ie: not ``blowing off to infinity'') as $n$ becomes ``very large''. Its calculation can be used to create \underline{\href{https://www.google.com.au/search?q=mandelbrot+set}{mathematical artwork}}.
\\ \\
\textbf{Task:} Write a C program which tests a given point $C$ for inclusion in the Mandelbrot set.
\\ \\
To do this you will be need to know that:
\begin{itemize}
\item $z$ and $C$ are complex numbers with real and imaginary parts
\item We will use the notation: \\
$z = x + iy$ \\
$C = x_0 + iy_0$
\item Using rules of complex arithmetic it can be shown that: \\
$z^2 + C= x^2 + i2xy - y^2 + x_0 + iy_0$
\item In 
\end{itemize}
\end{task}

\pagebreak 
\section{C Summary}
This section will be included in all future lab documents and lists a summary of C language features taught prior to the lab session. It will grow each week.

Not everything listed in this section is required to complete a particular lab.

\begin{multicols}{2}
\subsection{Basic Structure}
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int main() {
	// Your program goes here
	return 0;
}
\end{lstlisting}
\subsection{Comments}
\begin{lstlisting}[style=CStyle]
// This is a comment to end of line

/* this is a block comment
   which could span
   multiple
   lines
   */
\end{lstlisting}

\subsection{Code Blocks}

Any section of code encompassed by \texttt{\{...\}} is a \textit{block}.

\subsection{Operators}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
\hline
Operation      & C Symbol \\
\hline
Addition       & \texttt{+}        \\
Subtraction    & \texttt{-}        \\
Multiplication & \texttt{*}        \\
Division       & \texttt{/}       \\
Modulus		   & \texttt{\%}	\\
Increment	& \texttt{++}	\\
Decrement	& \texttt{--} \\
Less than       & $\texttt{<}$        \\
Less than or equal to    & $\texttt{<=}$\\
Greater than & $\texttt{>}$        \\
Greater than or equal to       & $\texttt{>=}$ \\
Equal to & \texttt{==} \\
Not equal to & \texttt{!=} \\
Boolean AND & \texttt{\&\&} \\
Boolean OR & \texttt{||} \\
Boolean NOT & \texttt{!} \\
\hline
\end{tabular}
\caption{Arithmetic operators in C}
\end{table}

\columnbreak
\subsection{Operator Shorthand}

Many arithmetic operators support the following shorthand syntax. The left and right columns present equivalent statements.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\texttt{x = x + y;} & \texttt{x += y;} \\
\texttt{x = x - y;} & \texttt{x -= y;} \\
\texttt{x = x * y;} & \texttt{x *= y;} \\
\texttt{x = x / y;} & \texttt{x /= y;} \\
\hline
\end{tabular}
\end{table}

\subsection{Data Types}

\begin{table}[H]
\begin{tabular}{|l|l|l|l|}
\hline
Type & Bytes & Value Range                             \\
\hline
\texttt{char}      & 1                  & -128, +127  \\
\texttt{unsigned char}	& 1				& 0, 255 \\
\texttt{short}     & 2                & -32768, 32767\\
\texttt{unsigned short} & 2			& 0, 65535 \\
\texttt{int}       & 4                & $\approx \pm 2.1\times 10^9$ \\
\texttt{unsigned int}	& 4				& 0, 4294967296 \\
\texttt{long}      & 8                  & $\approx \pm 9.2\times 10^{18}$ \\
\texttt{unsigned long} & 8				& 0, $1.8 \times 10^{19}$ \\
\texttt{float}       & 4  & $1.2\times 10^{-38}$ to $3.4 \times 10^{38}$    \\
\texttt{double}      & 8  & $2.3 \times 10^{-308}$ to $1.7 \times 10^{308}$    \\

\hline
\end{tabular}
\end{table}

\subsection{Standard i/o}

Read a single variable from \texttt{stdin} with \texttt{scanf();}
\texttt{scanf("\textit{format specifier}", \&\textit{variable}});

Write a single variable to \texttt{stdout} with \texttt{printf();}
\texttt{printf("\textit{format specifier}", \textit{variable});}

You can use \texttt{printf();} \textit{without} a newline (\texttt{\textbackslash n}) to create an input prompt:

\begin{lstlisting}[style=CStyle]
printf("Enter a number: ");
scanf("%d", &variable);
\end{lstlisting}

This prints:

\texttt{Enter a number: \_}

where \_ indicates the terminal prompt (ie: where typed characters will appear).

\subsection{Format Specifiers}
The following table is woefully incomplete. The compiler \textit{may} generate warnings if \texttt{\%d} is given something other than \texttt{int} and \texttt{\%f} is given something other than \texttt{float}. An attempt will be made to ensure these are sufficient.
\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
Data Type & Format Specifier \\
\hline
Integers & \texttt{\%d} \\
Floating point & \texttt{\%f} \\
Float with \texttt{n} decimal places & \texttt{\%.nf} \\
\hline
\end{tabular}
\caption{Basic format specifiers}
\end{table}

\subsection{Type Casting}
Placing the syntax \texttt{(\textit{type})} before a variable name performs a type cast (ie: data type conversion).

eg: convert \texttt{float} to an \texttt{int} prior to using its value. This forces a rounding-down to the nearest integer.

\begin{lstlisting}[style=CStyle]
float a;
// ...
y = (int)a * z;
\end{lstlisting}

\textbf{NB:} This does \textbf{not} modify the original variable.

Data type ``upgrades'' are done automatically by the compiler but sometimes it is desired to downgrade or force esoteric behaviour. Adding it unnecessarily doesn't have any negative impact. Applications in ENGG1003 will be limited but it comes up regularly in embedded systems and nobody else explicitly teaches type casting. I have used it extensively in the low-level art of \textit{bit banging}: manual manipulation of binary data. This is, unfortunately, beyond ENGG1003.

\subsection{Flow control}

Flow control allows selected blocks of code to execute multiple times or only under a specified condition.

\subsubsection{\texttt{if()}}

The \texttt{if()} statement executes a block of code only if the \textit{condition} is true. The condition is an arithmetic statement which evaluates to either zero (false) or non-zero (true).
\columnbreak

Syntax:

\texttt{if(\textit{condition}) \{/* other code */\}}

Full example:

\begin{lstlisting}[style=CStyle]
if(x > 10) {
	// Do stuff
}
\end{lstlisting}

Condition Examples:
\begin{itemize}
\item \texttt{if(x) // if(x is not zero)}
\item \texttt{if(x+y) //if((x+y) is not zero)}
\item \texttt{if(y >= 5)}
\item \texttt{if(1) // Always executes}
\item \texttt{if(0) // Never executes}
	\begin{itemize}
		\item Can be used for debugging. Might be easier than a block comment /* */
	\end{itemize}
\end{itemize}

\textbf{NB:} \textit{NEVER} place a semicolon after an \texttt{if()}, that stops it from having any effect. The block after it will always execute. This bug can take days to find.

If there is only \textit{one} statement after an \texttt{if()} the \{ \} braces are optional:

\begin{lstlisting}[style=CStyle]
if(x > 10) 
	printf("x is greater than 10\n");
\end{lstlisting}

\subsubsection{\texttt{if() ... else if()}}

The C syntax for IF ... ELSE is:

\begin{lstlisting}[style=CStyle]
if(condition) {
	// Do stuff
} else {
	// Do stuff
}
\end{lstlisting}

IF ... ELSEIF takes the form:

\begin{lstlisting}[style=CStyle]
if(condition) {
	// Do stuff
} else if(condition) {
	// Do stuff
}
\end{lstlisting}

Multiple ``layers'' of \texttt{else if()} can be written. You don't have to stop at two.

\subsubsection{\texttt{while()}}

The \texttt{while()} flow control statement executes a block of code so long as a condition is true. The condition is checked before the block is executed and before every repeated execution.

The condition rules and examples are the same as for those listed under the \texttt{if()} statement.

Syntax:

\texttt{while(\textit{condition)} \{/* other code */\}}

Example:

Evaluate the infinite sum:
\begin{equation}
\sum_{n=0}^{\infty} \frac{1}{n^2}
\end{equation}
to a precision of $1 \times 10^{-6}$
\begin{lstlisting}[style=CStyle]
float sum = 0.0;
int x = 0;
while(1/(x*x) > 1e-6) {
	sum = sum + 1.0/(x*x);
	x++
}
\end{lstlisting}

\subsection{Library Functions}
\subsubsection{\texttt{rand()}}

To generate a random number between \texttt{0} and \texttt{MAX}:

\begin{lstlisting}[style=CStyle]
#include <stdlib.h> // For rand()
// ...
x = rand() % MAX;
\end{lstlisting}

For all work in this course you may assume that the above method works well enough.

For more crucial work (eg: cryptography, serious mathematics) this method is considered problematic. Very advanced discussion \underline{\href{http://www.azillionmonkeys.com/qed/random.html}{Here}}.

\begin{lstlisting}[style=CStyle]
\end{lstlisting}


\begin{lstlisting}[style=CStyle]
\end{lstlisting}

\end{multicols}
\end{document}
