\documentclass{lab}

\usepackage{graphicx}
\usepackage{float}
\usepackage{soul}
\usepackage{multicol}

\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}

\title{ENGG1003 - Lab 2 (And Beyond)}
\author{Brenton Schulz}
\date{\today}

\begin{document}
\maketitle

\section{Feedback}

To help me write better labs please fill out this survey when you leave your \textbf{Week 2} lab:
\vspace{5mm} \\ 
\huge{\underline{\href{https://docs.google.com/forms/d/1wUgJlZGRcYm7_ZKBOxzc3DHkZv5UVqKQJ_EGQhSV55Q/}{Click here to complete the survey before you leave.}}}\\
\vspace{2mm}
\normalsize

I just want to know how many problems the ``average'' student can complete in 3 hours. It will also tell me which problems are more engaging than others (does everyone \textit{hate} probability? Do you love it? I have no idea.)

You likely won't be able to complete \textit{all} the problems, that is intentional. If 60\% of you complete the lab it means I don't know how many questions 60\% can do in 3hrs.

\section{Introduction}

This set of programming exercises leaves you to perform a series of tasks on your own. This can be daunting at first, but your ability to remain resolute and resourceful in an atmosphere of extreme pessimism\footnote{Yes, this is a reference to the computer game \textit{Portal} (2007).} will be a useful skill when studying Engineering\footnote{Talk to your demonstrators about how true this is. I write it only partially in jest. I've found it a necessary skill for \textit{life}.}. (In truth, I hope you don't find it \textit{that} hard and gain satisfaction and confidence from getting programs to work).

The example tasks are mostly ``toy'' programs. They don't do anything particularly useful because most ``real-world'' problems are too advanced for this stage of the course. Things will get more interesting in the coming weeks (I hope...).

Do not expect programs to compile (let alone \textit{work}) first go. It is totally normal, even for experienced programmers, for multiple lines of hand typed code to generate several errors the first time compilation is attempted. You will then find \textit{more} errors when they are executed and found to produce the wrong output.

In time you will learn to interpret and deal with error messages quickly. Typically they will be a syntax error due to a missing parenthesis, semicolon, or double quote. Don't be afraid to ask for help from demonstrators and work with other students in the lab.

In short: all of your time spent programming will be fixing problems because as soon as all the (known) problems are fixed you stop programming and ship the software to your customer.

Generally speaking, the development process follows repeated application of the following steps:

\begin{enumerate}
\item Make a code change
\item Compile
\item Fix compile errors, repeat until code compiles
\item Test program with known correct input-output data
\item Repeat whole process until correct output is generated for multiple test inputs
\end{enumerate}

I don't know how long these problems will take you to complete. With some adjustments, this may become a problem set for weeks 2 and 3.
\pagebreak
\section{Getting Started Questions}

Run though these questions quickly and ask your demonstrator if any appear confusing. These all cover basic fundamentals required to complete the later problems.

\begin{enumerate}
\item What are the values of \texttt{x, y, v,} and \texttt{z} after this code has executed?
\begin{lstlisting}[style=CStyle]
int x = 2;
int y, v;
float z;
x = x+5;
y = 2*x + 3;
v = y/x; // NB: integer division
z = (float)y/x; // Forced to floating point division
\end{lstlisting}
\item What is printed to the console if the user enters \texttt{13$<$enter$>$}?
\begin{lstlisting}[style=CStyle]
float k;
printf("Enter a number: ")
scanf("%f", &k);
k = 1.43*k + 84;
printf("%f\n", k);
printf("%d\n", (int)k); // Integer truncation
\end{lstlisting}
\item Write a \texttt{printf();} statement which takes an integer variable \texttt{temp} and prints:

\texttt{The temperature reading of 123 is dangerous}

to the screen (with 123 replaced with the actual value).
\item A variable is required which stores integers with a maximum possible value of ten billion. What C data type is required?
\item A variable is required to store a real number with 10 significant figures. What C data type is required?
\item Write a C code snippet which implements the following pseudocode (decrement implies a subtraction by 1):
\begin{lstlisting}[style=pseudo]
IF x is not equal to zero
	decrement x
ENDIF
\end{lstlisting}
 
\item Write a C code snippet which implements the following pseudocode:
\begin{lstlisting}[style=pseudo]
WHILE x is greater than 1
	y = y*x;
	x = x-1;
ENDWHILE
\end{lstlisting}
\item Write a C code snippet which implements the following pseudocode:
\begin{lstlisting}[style=pseudo]
BEGIN
	integer result
	READ x from the console
	IF x is zero
		result = -1
	ELSEIF x is -1
		result = 0
	ELSE
		result = 1
	ENDIF
END
\end{lstlisting}
\end{enumerate}

\section{Usage of \texttt{printf();} and \texttt{scanf();}}

In previous examples you have (likely) only seen \texttt{printf();} and \texttt{scanf();} print and read one variable at a time, eg:

\begin{lstlisting}[style=CStyle]
scanf("%d", &y);
printf("Number was: %d\n", k);
\end{lstlisting}

They can, however, be used to read or print arbitrarily many variables. To do this you:

\begin{enumerate}
\item Use multiple format specifiers (\texttt{\%d} and \texttt{\%f}) inside the \textit{format string}
\item List multiple variables, separated by commas, after the format string
\end{enumerate}

The format string is everything between the pair of double quotes: \texttt{printf("This is the format string\textbackslash n")}.

For example, to read three integers, \texttt{x, y,} and \texttt{z} from the console:

\begin{lstlisting}[style=CStyle]
int x,y,z; // This declares three int variables on one line
scanf("%d %d %d", &x, &y, &z);
\end{lstlisting}

The integers you type need to be separated by spaces (note that spaces are present inside the format string) and \texttt{$<$enter$>$} typed to end the line. The \texttt{scanf();} function won't process any data until an end of line is read.

Note that the order is \textit{crucial}; the numbers you type will go into \texttt{x, y} and \texttt{z} in the the same order that the variable names are listed in \texttt{scanf();}.

You don't \textit{need} to separate the input with spaces. You can, for example, read an hh:mm time with:

\begin{lstlisting}[style=CStyle]
scanf("%d:%d", &hours, &minutes);
\end{lstlisting}

and \texttt{scanf();} will match the integer-colon-integer pattern with the input and extract hours and minutes.

\texttt{scanf();} even supports incredibly advanced ``pattern matching'' but it is \textit{well} beyond the scope of ENGG1003.

Note that the numbers don't all need to be integers. You can mix integers and, say, \texttt{double}s:

\begin{lstlisting}[style=CStyle]
int x,y; // This declares three int variables on one line
double z;
scanf("%d %d %f", &x, &y, &z);
\end{lstlisting}

Likewise, the \texttt{printf();} function can print multiple numbers in arbitrary locations. You can write a mixture of \texttt{\%d} and \texttt{\%f} anywhere inside the format string and values will be pulled from the list of variables in order.

For example:

\begin{lstlisting}[style=CStyle]
int a = 1, b = 2;
float c = 1.23;
double d = 8.2;
printf("%d is an integer, %d is an integer, have some more numbers: %f %f\n", a, b, c, d);
\end{lstlisting}

will print:

\texttt{1 is an integer, 2 is an integer, have some more numbers: 1.23 8.2}

Lastly, if you get this compiler warning:


\texttt{main.c:6:13: warning: format ‘\%d’ expects argument of type ‘int *’, but argument 3 has type ‘float *’ [-Wformat=]
  scanf("\%d:\%d", \&h, \&m);}


it means that the data type and format specifier don't match. You have made a mistake, fix it.


\pagebreak
\section{Input-Processing-Output Exercises}

These exercises all require the use of \texttt{scanf();} to read data, some arithmetic to process data, and \texttt{printf();} to print results to the console.

Every task requires the following steps:

\begin{enumerate}
\item Work out what variables are required
\item What \textit{type} do the variables need to be?
\item Convert an equation to C code. Do we need to be careful with data types?
\item Write a \texttt{scanf();} statement to read the user's input
\item Write a \texttt{printf();} statement to print the result
\item (Optional) Do you want the user to be \textit{prompted}? This is when text appears in the console telling the user what to enter. This requires a \texttt{printf();} prior to the \texttt{scanf();}
\item (Optional) Does the output need to be in a human sentence? Write the \texttt{printf();} statement.
\item (Optional) Should you limit the precision of the printed result? Are 6 decimal places appropriate? Should it only be 1? Use the \texttt{\%.nf} format specifier to limit floating point precision to \texttt{n} decimal places
\end{enumerate}

The following template can be used for all these exercises:

\begin{lstlisting}[style=CStyle]
#include <stdio.h>

int main() {
	// Declare the required variables 
	// eg: int x; float y; etc	
	
	// Get input from the user
	// eg: 	printf("Enter a number: ");
	// 		scanf("%f", &y);	
	
	// Do the calculation
	// x = ....whatever
	
	// Print result to user
	// eg: Printf("%d times %d is %d\n", x, y, z);
		
	return 0;
}
\end{lstlisting}

\pagebreak
\begin{task}{Temperature Conversion}{}
The formula for converting temperatures in Farenheit, $F$ to Celsius, $C$, is:

\begin{equation}\label{eq:temp}
C = \frac{5}{9}(F - 32).
\end{equation}

Given the C template, write a program which performs this conversion. It should read the Farenheit temperature from \texttt{stdin} and print the result to \texttt{stdout}. The program should correctly handle any practical real values (eg: 19.38) as input. Print the result to 2 decimal places.
\\ \\
Test your code with several values calculated with \underline{\href{https://www.google.com.au/search?q=farenheit+to+celsius}{Google}}.
\end{task}

\begin{task}{Variance Calculation}{}
From statistics, the \textit{sample variance}, $s^2$, of $N$ samples can be calculated as:

\begin{equation}\label{eq:var}
s^2 = \frac{\sum_{k=1}^{N}(X_k - mean(X))}{N-1}.
\end{equation}

Write a C program which reads \textbf{four} numbers and outputs their sample variance.
\\ \\
Given that $N = 4$ (and some algebra) Equation \ref{eq:var} can be expanded into two steps:

\begin{enumerate}
\item Calculate the sample mean: $\texttt{mean} = \frac{1}{4} \times \left( X_1 + X_2 + X_3 + X_4 \right)$
\item Calculate the variance: $\texttt{var} = \frac{1}{3} \times ((X_1 + X_2 + X_3 + X_4 - 4 \times \texttt{mean})$
\end{enumerate}

Your program will have to declare four \texttt{float} variables to store the four input values. To read four numbers in one instance of \texttt{scanf();} you can do this:

\begin{lstlisting}[style=CStyle]
float x1, x2, x3, x4;
scanf("%f %f %f %f", &x1, &x2, &x3, &x4);
\end{lstlisting}

Test your program given that the variance of the set (1, 2, 3, 4) = 1.6667
\\ \\
\textbf{NB:} Be careful with the $\frac{1}{4}$ and $\frac{1}{3}$ constants in the equations above. They may experience integer division problems. If in doubt, convert them to floating point literals.
\end{task}

\begin{task}{Linear Interpolation}{}
There are many instances in science and engineering when data needs to be \textit{interpolated}. Informally, this is the process of predicting a quantity's value somewhere between two (or more) data points.
\\ \\
In this task you will be using the \textit{two-point formula} (you saw this in high school, right?) to interpolate between two data points. You can imagine these data points to be measurements of temperature / brightness / sound intensity / pressure / etc as a function of time.\\ \\
The two-point formula states that the equation of a line passing through two points $(x_1, y_1)$ and $(x_2, y_2)$ is:
\begin{equation}
y = \frac{y_2 - y_1}{x_2 - x_1}(x - x_1) + y_1.
\end{equation}
The value of $y$ at some given $x$ can then be estimated. For the purposes of interpolation $x$ will always be in between the given data points. ie, assuming $x_2 > x_1$:
\begin{equation}
x_2 > x > x_1.
\end{equation}
Note that $y$ is only an \textit{estimate} of the true value. You will often see this notated as $\hat{y}$, especially in statistics.
\\ \\
The process of estimating values outside the $[x_1, x_2]$ interval is known as \textit{extrapolation}\footnote{\url{https://xkcd.com/605/}} and is beyond the scope of this task.
\\ \\
Given the above, write a C program which implements the following pseudocode:
\begin{lstlisting}[style=CStyle]
BEGIN
	READ x1 and y1 from the console
	READ x2 and y2 from the console
	READ a point x from the console
	Estimate the value of y at x using linear interpolation
	PRINT y
END
\end{lstlisting}
To understand this problem you will find it useful to draw some sketches. Draw an x-y axis, dot two points and draw a line between them. If you pick two neat integer points (eg: 0,0 and 5,5) then the linear interpolation will be easy to see by eye. Perform several tests with known-correct sets of values to confirm that your code is correct.
\\ \\
Program implementation notes:
\begin{itemize}[itemsep=1mm]
\item Reading a pair of points can be done with:
\begin{lstlisting}[style=CStyle]
float x1, y1;
printf("Enter point 1: ");
scanf("%f %f", &x1, &y1);
\end{lstlisting}
you would then type two numbers into the console, separated by a space, and press enter.
\item Keep all variables as \texttt{float} or \texttt{double}. It doesn't \textit{really} matter which, just be consistent.
\end{itemize}
\end{task}

\pagebreak
\section{Flow Control Exercises}

This first task presents you with all the required building blocks to implement a simple algorithm. All this program will do is read in 2 integers, perform a division, then print the result. A check is performed to make sure a division by zero does not occur.

\begin{task}{}{}
Write a program which implements the following pseudocode:

\begin{lstlisting}[style=pseudo]
BEGIN 
	Integer a 
	Integer b
	Integer c
	Read an integer from standard input, store it in a
	Read an integer from standard input, store it in b
	IF b is zero
		PRINT "Division by zero error"
	ELSE
		c = a/b
		PRINT "a divided by b is" <the value of c>
	ENDIF
END
\end{lstlisting}

Notes:

\begin{itemize}
\item Reading each integer can be done with: \texttt{scanf("\%d", \&a);} (with an appropriate substitution for the variable name). You may prompt the user by placing a \texttt{printf();} \textit{without} newline character prior to \texttt{scanf();}, eg:

\begin{lstlisting}[style=CStyle]
printf("Enter an integer: ");
scanf("%d", &a);
\end{lstlisting}

\item Note that $<$the value of c$>$ in the pseudocode is implying that a number should be printed there, ie:

\begin{lstlisting}[style=CStyle]
printf("a divided by b is %d\n", c);
\end{lstlisting}

\item The condition "b is zero" needs to be implemented with the \texttt{==} (\textit{two} equals symbols) operator.

\item You may start with the default code listing provided by OnlineGDB
\end{itemize}
\end{task}

\begin{task}{Calculating Square Roots}{}
The square root of a number, $x = \sqrt{n}$, can be calculated with the iterative formula:
\begin{equation}\label{eq:sqrt}
x_{k+1} = \frac{1}{2}\left(x_k + \frac{n}{x_k}\right)
\end{equation}
Implement an algorithm which uses this formula to calculate square roots of real numbers. The value of $n$ is to be read from the console with \texttt{scanf();} and the result printed with \texttt{printf();}.
\\ \\
The choice of $x_0$ is somewhat arbitrary, the algorithm should converge given any sane value (ie: not infinity), but will converge faster if $x_0$ is closer to the true value of $\sqrt{n}$. You may play with this value and observe any differences. Common choices would be setting it to $n$ or 1.
\\ \\
The algorithm will require a loop. The exit condition could be one of several choices. In order of difficulty:
\begin{enumerate}
\item Exit after a fixed number of iterations (eg: 10)
\item Exit when $\left| x_k - x_{k-1} \right| < e$ where $e$ is some pre-defined precision of your choosing
\item Exit when either of the above conditions are met
\end{enumerate}

To calculate precision you will need to explicitly save $x_k$ and $x_{k-1}$ in different variables.
\\ \\
\textbf{Hint:} You can place \texttt{printf();} statements inside the loop to help you debug. Calculate the series of $x_n$'s for a particular value (eg: $\sqrt{2}=1.4142$) by hand (with the same value for $x_0$) so that you can compare your program's output with an output you have confidence in.
\end{task}\label{tsk:sqrt}

\begin{task}{Quadratic Equation Analysis}{}
The Friday Week 1 lecture introduced the following pseudocode for solving quadratic equations:
\begin{lstlisting}[style=pseudo]
BEGIN
	INPUT: a, b, c
	D = b^2 - 4ac
	IF D < 0
		 N = 0
	ELSEIF D == 0
		N = 1
		x1 = -b/(2a)
	ELSEIF D > 0
		N = 2
		x1 = (-b + sqrt(D))/(2a)
		x2 = (-b - sqrt(D))/(2a)
	ENDIF
	OUTPUT: N, x1, x2
END
\end{lstlisting}

\textbf{Everyone:} Write a C program which takes the \texttt{a, b,} and \texttt{c} values and outputs the number of real valued solutions which exist (ie: 0, 1, or 2).
\\ \\
\textbf{Everyone:} Introduce a ``temporary'' variable (ie: short lived, one we stop caring about soon after it is used) which explicitly removes the requirement to calculate \texttt{sqrt(D)} twice.
\\ \\
\textbf{Advanced:} Using the square root algorithm in Equation \ref{eq:sqrt}, implement the full quadratic equation solution algorithm.
\end{task}

\pagebreak
\section{Random Numbers}

The following tasks involve generating and using random numbers. The standard C library (glibc, in Linux and MinGW, provided by the \underline{\href{https://en.wikipedia.org/wiki/GNU_Project}{GNU project}}) contains a function called \texttt{rand();} which creates a random number between 0 and a constant called \texttt{RAND\_MAX}. In glibc \texttt{RAND\_MAX} is 2147483647, or the maximum value an \texttt{int} can store. It may vary between implementations (older systems may use 32767, for example).

Because \texttt{rand();} is part of a ``library'' and not built into the C language you need to include a \textit{header file} which describes to the compiler what \texttt{rand();} is before it is used. To do this, type the following line at the top of your source listing (anywhere above \texttt{main()}):

\begin{lstlisting}[style=CStyle]
#include <stdlib.h>
\end{lstlisting}

The \texttt{rand();} function can then be included in your code. You can write it in all the same places that you would write a variable or literal. All of the following statements are valid:

\begin{lstlisting}[style=CStyle]
x = rand();
y = 10 + rand() % 5;
printf("A random number is: %d\n", rand() );
\end{lstlisting}

Generally you aren't after a random number between 0 and \texttt{RAND\_MAX}. To limit the rand of integers generated we can use the modulus (\texttt{\%}) operator. For the purposes of this course the following methods can be used to generate:

\begin{itemize}
\item A number between 0 and \texttt{MAX}:
\begin{lstlisting}[style=CStyle]
x = rand() % (MAX + 1);
\end{lstlisting}

\item A number between 1 and \texttt{MAX}:
\begin{lstlisting}[style=CStyle]
x = rand() % MAX + 1;
\end{lstlisting}

\item A floating point number between 0 and \texttt{MAX}:
\begin{lstlisting}[style=CStyle]
x = (float)rand()/RAND_MAX * MAX;
\end{lstlisting}
\textbf{NB:} \texttt{rand();} becomes an \texttt{int} so an explicit cast to \texttt{float} (or \texttt{double}) is required to avoid integer division errors.

\end{itemize}

\begin{task}{Rolling Dice}{}
Using the \texttt{rand();} function, write a C program which estimates the probability that, when two dice are thrown, at least one of the dice rolled a 3. This can be done with the following algorithm:
\begin{lstlisting}[style=pseudo]
BEGIN
	counter = 0;
	aThreeHappened = 0
	WHILE counter < 1000
		a = random number between 1 and 6
		b = random number between 1 and 6
		IF (a == 3) OR (b == 3)
			aThreeHappened = aThreeHappened + 1
		END
		counter = counter + 1
	ENDWHILE
	PRINT aThreehappened / counter
END
\end{lstlisting}

The theoretical value is $\frac{11}{36} = 0.3055$
\end{task}

\begin{task}{Arithmetic Tutor}{}
Write a C program which can be used to teach basic arithmetic to primary school children.
\\ \\
Your program should follow the following algorithm:
\begin{lstlisting}[style=pseudo]
BEGIN
	integer max
	READ max from the user
	integer a = a random number between 1 and max
	integer b = a random number between 1 and max
	integer c = a + b
	PRINT What is a + b? // a and b the numerical values
	READ an integer d
	IF c == d
		PRINT "Correct!"
	ELSE
		PRINT "Wrong :(. The correct answer is " c
	ENDIF
END
\end{lstlisting}
\textbf{Extension 1:} Modify the algorithm so that it keeps generating problems until the user gets one wrong. (ie: Chuck a \texttt{while()} around the appropriate lines, create a variable which records if the answer was wrong or correct, and test that variable in the \texttt{while()} condition).
\\ \\
\textbf{Extension 2:} Add a variable which keeps score and prints the number of correctly answered questions on program exit.
\\ \\
\textbf{Advanced:} Add a menu to the start of the program which allows the user to select between addition, subtraction, multiplication, and division. Implement integer division where the user must enter the result as quotient and remainder.
\end{task}

\begin{task}{Calculating Pi}{}
Implement the $\pi$ calculation algorithm talked about during lectures. The pseudocode is:
\begin{lstlisting}[style=pseudo]
BEGIN
        integer countTotal = 0
        integer countInside = 0
        WHILE countTotal < A large number
                x = random number between 0 and 1
                y = random number between 0 and 1
                countTotal = countTotal + 1
                IF x*x + y*y < 1
                        countInside = countInside + 1
                ENDIF
        ENDWHILE
        pi = 4*countInside/countTotal
        PRINT pi
END
\end{lstlisting}
\textbf{NB:} If running this on OnlineGDB use a ``small'' value for the maximum loop count. Try one million. If this takes longer than around 10 seconds to execute use a smaller value. You are occupying OnlineGDB's shared CPU resources when running this program.
\end{task}

\pagebreak
\section{Mandelbrot Set - Advanced}
\textit{This problem is presented for students interested in mathematics. It may take several lab sessions to correctly implement this task. If you do not understand anything here, do not be troubled. Do not feel the need to attempt this task. The mathematics is beyond the scope of ENGG1003.} \\ \\
\textit{Demonstrators are not to help you solve this problem. It is intended for students who have advanced beyond expectations, doing it alone is part of the challenge.}\\

A complex number, $C$, exists within the \textit{Mandelbrot set} if, when iterated with the formula:

\begin{equation}
z_{n+1} = z^2_n + C,
\end{equation}

with initial condition $z_0 = 0$, the value of $\left|z_n\right|$ stays bounded (ie: doesn't ``blow off to infinity'') as $n$ becomes ``very large''. It's calculation can be used to create \underline{\href{https://www.google.com.au/search?q=mandelbrot+set}{mathematical artwork}}. Hanging in my office is a piece of art known as a \underline{\href{https://www.google.com.au/search?q=buddahbrot}{Buddahbrot}}. Calculation took several days on an R9 270X gaming graphics card. Come check it out some time. I have an unhealthy love of this branch of mathematics.
\\ \\
Purely real examples:
\begin{itemize}
\item $C = 0.1$ is \textit{inside} the Mandelbrot set, as:
\begin{align}
z_1 &= 0 + 0.1 \\
z_2 &= 0.1^2 + 0.1 = 0.11 \\
z_3 &= 0.11^2 + 0.1 = 0.1121 \\
... \\
z_{14} &= 0.112701665^2 + 0.1 = 0.112701665 \\
Z_{15} &= 0.112701665^2 + 0.1 = 0.112701665 
\end{align}
...and it just sits at 0.112701665 forever.
\item $C = 1$ is \textit{outside} the Mandelbrot set, as:
\begin{align}
z_1 &= 0 + 1 \\
z_2 &= 1^2 + 1 = 2 \\
z_3 &= 2^2 + 1 = 5 \\
z_4 &= 5^2 + 1 = 26 \\
z_5 &= 26^2 + 1 = 677 \\
... \\
z_{11} &= (3.79 \times 10^{90})^2 + 1 = 1.4 \times 10^{181}
\end{align}
...and it just keeps getting bigger. Fast.
\end{itemize}

\begin{task}{}{} Write a C program which tests a \textit{single} point, $C$, for inclusion in the Mandelbrot set. This code can be expanded to draw an image in a later lab.
\end{task}

To do this you will be need to know that:
\begin{itemize}[itemsep=0mm]
\item $z$ and $C$ are complex numbers with real and imaginary parts

\item Introducing some notation:
\begin{align}
z_n &= x_n + iy_n \\
C &= x_0 + iy_0
\end{align}
Where $x$ denotes a real part and $y$ the imaginary.
\item Using rules of complex arithmetic it can be shown that:
\begin{align}
z_{n+1} &= z^2_{n} + C \\
&= x^2_n + i2x_ny_n - y^2_n + x_0 + iy_0
\end{align}
\item To evaluate this on a computer which only deals with \textit{real} numbers it has to be split into real and imaginary parts:
\begin{align}
Re(z_{n+1}) = x_{n+1} &= x^2_n - y^2_n + x_0\\
Im(z_{n+1}) = y_{n+1} &= 2x_ny_n + y_0
\end{align}
\item A complex number's norm (or absolute value, informally its ``size'') can be calculated as:
\begin{equation}
\left|z\right| = \sqrt{x^2 + y^2}
\end{equation}
and is needed to test if $z_n$ is getting ``too big''. For this problem, ``too big'' is typically defined as ``outside a circle of radius 2''. To avoid having to calculate the square root (which can be slow) you can take the so-called \textit{escape condition} as:
\begin{equation}
x^2 + y^2 > 4
\end{equation}
In code, this will go inside a loop's exit condition. Either as a ``NOT (x*x+y*y $>$ 4)'' or, more simply, ``x*x + y*y $<$ 4'' as loop conditions need to remain TRUE for the loop to continue.
\item The loop which implements the iterative equation needs to keep track of the iteration count but does \textit{not} need to record a full history of $z_n$'s. You only need the ''next'' and ''current' values of $x_n$ and $y_n$. At some point an assignment causes the ``next'' to become the ``current''.
\item An \textit{iteration limit} needs to be set. A point, $C$, is considered ``inside'' the set if the iteration limit is hit without $\left|z_n\right|$ exceeding $2$.
\item If $\left|z_n\right| > 2$ before the iteration limit is hit the point, $C$, is inside the Mandelbrot set
\item Full, somewhat optimised, pseudocode for this problem can be found on \underline{\href{https://en.wikipedia.org/wiki/Mandelbrot_set}{Wikipedia}}. Independent research may be required to implement this problem.
\item For testing purposes here are some test points with an iteration limit of 1000:
	\begin{itemize}
		\item $C = 0 + i0$ takes 1000 iterations
		\item $C = 0.5 + i0$ takes 4 iterations
		\item $C = 0.4 +i0.1$ takes 7 iterations
		\item $C = 0.38 +i0.1$ takes 35 iterations
		\item $C = -0.38 +i0.1$ takes 1000 iterations
		\item If all these test points take an iteration count which is offset by 1 from my solution your code is probably fine. This kind of error happens all the time due to $<$ Vs $<=$ and the like.
	\end{itemize}
\end{itemize}


\pagebreak 
\section{C Summary}
This section will be included in all future lab documents and lists a summary of C language features taught prior to the lab session. It will grow each week.

Not everything listed in this section is required to complete a particular lab.

\begin{multicols}{2}
\subsection{Basic Structure}
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int main() {
	// Your program goes here
	return 0;
}
\end{lstlisting}
\subsection{Comments}
\begin{lstlisting}[style=CStyle]
// This is a comment to end of line

/* this is a block comment
   which could span
   multiple
   lines
   */
\end{lstlisting}

\subsection{Code Blocks}

Any section of code encompassed by \texttt{\{...\}} is a \textit{block}.

\subsection{Operators}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
\hline
Operation      & C Symbol \\
\hline
Addition       & \texttt{+}        \\
Subtraction    & \texttt{-}        \\
Multiplication & \texttt{*}        \\
Division       & \texttt{/}       \\
Modulus		   & \texttt{\%}	\\
Increment	& \texttt{++}	\\
Decrement	& \texttt{--} \\
Less than       & $\texttt{<}$        \\
Less than or equal to    & $\texttt{<=}$\\
Greater than & $\texttt{>}$        \\
Greater than or equal to       & $\texttt{>=}$ \\
Equal to & \texttt{==} \\
Not equal to & \texttt{!=} \\
Boolean AND & \texttt{\&\&} \\
Boolean OR & \texttt{||} \\
Boolean NOT & \texttt{!} \\
\hline
\end{tabular}
\caption{Arithmetic operators in C}
\end{table}

\columnbreak
\subsection{Operator Shorthand}

Many arithmetic operators support the following shorthand syntax. The left and right columns present equivalent statements.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\texttt{x = x + y;} & \texttt{x += y;} \\
\texttt{x = x - y;} & \texttt{x -= y;} \\
\texttt{x = x * y;} & \texttt{x *= y;} \\
\texttt{x = x / y;} & \texttt{x /= y;} \\
\hline
\end{tabular}
\end{table}

\subsection{Data Types}

\begin{table}[H]
\begin{tabular}{|l|l|l|l|}
\hline
Type & Bytes & Value Range                             \\
\hline
\texttt{char}      & 1                  & -128, +127  \\
\texttt{unsigned char}	& 1				& 0, 255 \\
\texttt{short}     & 2                & -32768, 32767\\
\texttt{unsigned short} & 2			& 0, 65535 \\
\texttt{int}       & 4                & $\approx \pm 2.1\times 10^9$ \\
\texttt{unsigned int}	& 4				& 0, 4294967296 \\
\texttt{long}      & 8                  & $\approx \pm 9.2\times 10^{18}$ \\
\texttt{unsigned long} & 8				& 0, $1.8 \times 10^{19}$ \\
\texttt{float}       & 4  & $1.2\times 10^{-38}$ to $3.4 \times 10^{38}$    \\
\texttt{double}      & 8  & $2.3 \times 10^{-308}$ to $1.7 \times 10^{308}$    \\

\hline
\end{tabular}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|}
\hline
Type & Precision \\
\hline
\texttt{float} & 6 sig. figs. \\
\texttt{double} & 15 sig. figs \\
\hline
\end{tabular}
\end{table}


\subsection{Standard i/o}

Read a single variable from \texttt{stdin} with \texttt{scanf();}
\texttt{scanf("\textit{format specifier}", \&\textit{variable}});

Write a single variable to \texttt{stdout} with \texttt{printf();}
\texttt{printf("\textit{format specifier}", \textit{variable});}

You can use \texttt{printf();} \textit{without} a newline (\texttt{\textbackslash n}) to create an input prompt:

\begin{lstlisting}[style=CStyle]
printf("Enter a number: ");
scanf("%d", &variable);
\end{lstlisting}

This prints:

\texttt{Enter a number: \_}

where \_ indicates the terminal prompt (ie: where typed characters will appear).

\subsection{Format Specifiers}
The following table is woefully incomplete. The compiler \textit{may} generate warnings if \texttt{\%d} is given something other than \texttt{int} and \texttt{\%f} is given something other than \texttt{float}. An attempt will be made to ensure these are sufficient.
\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
Data Type & Format Specifier \\
\hline
Integers & \texttt{\%d} \\
Floating point & \texttt{\%f} \\
Float with \texttt{n} decimal places & \texttt{\%.nf} \\
\hline
\end{tabular}
\caption{Basic format specifiers}
\end{table}

\subsection{Type Casting}
Placing the syntax \texttt{(\textit{type})} before a variable name performs a type cast (ie: data type conversion).

eg: convert \texttt{float} to an \texttt{int} prior to using its value. This forces a rounding-down to the nearest integer.

\begin{lstlisting}[style=CStyle]
float a;
// ...
y = (int)a * z;
\end{lstlisting}

\textbf{NB:} This does \textbf{not} modify the original variable.

Data type ``upgrades'' are done automatically by the compiler but sometimes it is desired to downgrade or force esoteric behaviour. Adding it unnecessarily doesn't have any negative impact. Applications in ENGG1003 will be limited but it comes up regularly in embedded systems and nobody else explicitly teaches type casting. I have used it extensively in the low-level art of \textit{bit banging}: manual manipulation of binary data. This is, unfortunately, beyond ENGG1003.

\subsection{Flow control}

Flow control allows selected blocks of code to execute multiple times or only under a specified condition.

\subsubsection{\texttt{if()}}

The \texttt{if()} statement executes a block of code only if the \textit{condition} is true. The condition is an arithmetic statement which evaluates to either zero (false) or non-zero (true).

Syntax:

\texttt{if(\textit{condition}) \{/* other code */\}}

Full example:

\begin{lstlisting}[style=CStyle]
if(x > 10) {
	// Do stuff
}
\end{lstlisting}

Condition Examples:
\begin{itemize}
\item \texttt{if(x) // if(x is not zero)}
\item \texttt{if(x+y) //if((x+y) is not zero)}
\item \texttt{if(y >= 5)}
\item \texttt{if(1) // Always executes}
\item \texttt{if(0) // Never executes}
	\begin{itemize}
		\item Can be used for debugging. Might be easier than a block comment /* */
	\end{itemize}
\end{itemize}

\textbf{NB:} \textit{NEVER} place a semicolon after an \texttt{if()}, that stops it from having any effect. The block after it will always execute. This bug can take days to find.

If there is only \textit{one} statement after an \texttt{if()} the \{ \} braces are optional:

\begin{lstlisting}[style=CStyle]
if(x > 10) 
	printf("x is greater than 10\n");
\end{lstlisting}

\subsubsection{\texttt{for(;;)}}

The \texttt{for(;;)} loop syntax is:

\begin{lstlisting}[style=CStyle]
for( initial ; condition ; increment ) {
	// Do stuff
}
\end{lstlisting}

The three sub-parts have the following behaviour:

\begin{itemize}
\item \textbf{Initial:} Code which is executed \textit{once}, before the loop is entered
\item \textbf{Condition:} A condition which is tested \textit{before} every loop iteration
\item \textbf{Increment:} Code which is executed \textit{after} every iteration
\end{itemize}

\texttt{for(;;)} Example:

\begin{lstlisting}[style=CStyle]
int x;
for( x = 0 ; x < 10 ; x++ ) {
	printf("%d ", x);
}
\end{lstlisting}

will print:

\texttt{0 1 2 3 4 5 6 7 8 9}

The \texttt{for(;;)} loop example doesn't print \texttt{10} because the condition is ``strictly less than 10''. When x is incremented to 10 the condition fails and the loop exits. It prints 0 because the increment is only applied \textit{after} the loop has run once.

\subsubsection{\texttt{if() ... else if()}}

The C syntax for IF ... ELSE is:

\begin{lstlisting}[style=CStyle]
if(condition) {
	// Do stuff
} else {
	// Do stuff
}
\end{lstlisting}

IF ... ELSEIF takes the form:

\begin{lstlisting}[style=CStyle]
if(condition) {
	// Do stuff
} else if(condition) {
	// Do stuff
}
\end{lstlisting}

Multiple ``layers'' of \texttt{else if()} can be written. You don't have to stop at two.

\subsubsection{\texttt{while()}}

The \texttt{while()} flow control statement executes a block of code so long as a condition is true. The condition is checked before the block is executed and before every repeated execution.

The condition rules and examples are the same as for those listed under the \texttt{if()} statement.

Syntax:

\texttt{while(\textit{condition)} \{/* other code */\}}

Example:

Evaluate the infinite sum:
\begin{equation}
\sum_{n=0}^{\infty} \frac{1}{n^2}
\end{equation}
to a precision of $1 \times 10^{-6}$
\begin{lstlisting}[style=CStyle]
float sum = 0.0;
int x = 0;
while(1/(x*x) > 1e-6) {
	sum = sum + 1.0/(x*x);
	x++
}
\end{lstlisting}

\subsection{Library Functions}
\subsubsection{\texttt{rand()}}

To generate a random number between \texttt{0} and \texttt{MAX}:

\begin{lstlisting}[style=CStyle]
#include <stdlib.h> // For rand()
// ...
x = rand() % (MAX + 1);
\end{lstlisting}

For all work in this course you may assume that the above method works well enough.

For more crucial work (eg: cryptography, serious mathematics) this method is considered problematic. Very advanced discussion \underline{\href{http://www.azillionmonkeys.com/qed/random.html}{Here}}.

\begin{lstlisting}[style=CStyle]
\end{lstlisting}


\begin{lstlisting}[style=CStyle]
\end{lstlisting}

\end{multicols}
\end{document}
