\documentclass{lab}

\usepackage{graphicx}
\usepackage{float}
\usepackage{soul}
\usepackage{multicol}

\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}

\title{ENGG1003 - Lab Week 5}
\author{Brenton Schulz}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

This lab covers C \textit{functions} and \texttt{static} variables.

\begin{task}{Statistics Calculations}{}
Write a C program which accepts a ``reasonably'' large number of real numbers from the user and calculates the set's mean and sample variance.
\end{task}

\begin{task}{Numerical Integration}{}
Write a C program which implements the following equation:
\begin{equation*}
f(x) = 2x^2 + 5x + \sin(15x)
\end{equation*}
and uses the trapezoidal rule to numerically calculate its integral between two given points: $x_1$ and $x_2$ (ensure $x_1 < x_2$).
\end{task}

\begin{task}{Fibonacci Sequence Generator Function}{}
\textbf{Review:} The Fibonacci Sequence is a sequence of integers:
\begin{equation*}
x_1, x_2, x_3, ..., 
\end{equation*}
where:
\begin{align*}
x_1 &= 1\\
x_2 &= 1\\
x_n &= x_{n-1} + x_{n-2}
\end{align*}
\textbf{Task:} Write a C function which, each time it is called, returns the next value of the Fibonacci sequence. This will require the use of \texttt{static} variables within the function. Use the following function prototype:
\begin{lstlisting}[style=CStyle]
unsigned int fib(void);
\end{lstlisting}

You can use the following template:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>

unsigned int fib(void);

int main () {
	int n;
	
	for(n = 0; n < 10; n++)
		printf("%d %x\n", n, fib() ); //%x formats an unsigned int
} 
\end{lstlisting}

After correctly implementing the function definition for \texttt{fib()} your program output should be:
\begin{lstlisting}[style=pseudo]
1 1
2 1
3 2
4 3
5 5
6 8
7 13
8 21
9 34
\end{lstlisting}
\end{task}

\pagebreak
\begin{task}{Mandelbrot Images - Advanced}{}
Starting from a completed solution to the Week 3 Mandelbrot problem modify your code to generate an ASCII netpbm ``portable PixMap'' (PPM) formatted image.
\subsection*{PPM Image Format}
The PPM format specification allows images to be written to files using only plain text (ASCII) data. This results in a \textit{very} simple file format which is easy to create with basic programs.\\
~\\
The file header has the following format:
\begin{lstlisting}[style=pseudo]
P3
<x resolution> <y resolution>
<max value>
\end{lstlisting}
where:
\begin{itemize}
	\item \texttt{P3} is a ``magic number'' identifying the format
	\item \texttt{$<$x resolution$>$} is the number of pixels horizontally
	\item \texttt{$<$y resolution$>$} is the number of pixels vertically
	\item \texttt{$<$max value$>$} is the pixel value corresponding to maximum brightness. Typically \texttt{255}.
\end{itemize}
An example header for a 100x100 pixel image would be:
\begin{lstlisting}[style=pseudo]
P3
100 100
255
\end{lstlisting}
After the header comes the \textit{body}. This is a list of \textbf{integer} RGB triplet numbers, separated by whitespace. The exact format is not critical, but I recommend the following:
\begin{lstlisting}[style=pseudo]
R G B
R G B
R G B
...etc
\end{lstlisting}
The pixel data scans left-to-right top-to-bottom (ie: top left pixel is first, bottom right pixel is last). This is the same order in which the Week 3 task calculated pixel values.

\subsection*{Colouring Fractal Images}
In order to colour a fractal image a mapping is used which converts each pixel's \textit{iteration count} to a colour. There are a near-infinite number of choices for this and I strongly recommend you research so-called ``colorbar'' creation. For this task I recommend the following two options:
\begin{enumerate}
	\item For debugging, use a grayscale mapping which uses the following formula for a pixel brightness, $p$, given the number of \texttt{iters} a pixel took to escape:
		\begin{equation*}
			p = 255 \times \frac{\texttt{iters}}{\texttt{MAX\_ITERS}}
		\end{equation*}
		To create greyscale images the RGB values of a pixel must be equal. This means that after you calculate $p$ you can just use 
\begin{lstlisting}[style=pseudo]
R = p;
G = p;
B = p; 
\end{lstlisting}

to make R, G and B equal. \textbf{NB:} The PPM format requires the output numbers to be \textbf{integers}!\\~
	\item More interesting colour mappings can be built with the use of the HSL (Hue-Saturation-Luminance) colourspace. This is a set of 3 numbers (H, S and L) which define a unique colour based on their hue (base colour from the rainbow), saturation (``colourfull-ness'') and luminance (brightness). 
\\~\\
You can then slightly tweak the previous formula to provide a H value and fix S and L at 1.0:
\begin{align*}
H &= 360 \times \frac{\texttt{iters}}{\texttt{MAX\_ITERS}}\\
S &= 1.0\\
L &= 1.0
\end{align*}
Because the PPM image format only supports RGB pixel formats you will need to implement formulas which convert HSV triplets to RGB values. \underline{\href{https://www.rapidtables.com/convert/color/hsv-to-rgb.html}{Wikipedia}} lists the set of formulas. Implement them in code, either as three functions or just as ``inline'' code.
\\~\\
You can attempt to write a single function which accepts a pointer to an array of 3 \texttt{float}s but we won't cover the details of this for a couple of weeks.
\end{enumerate}
~\\
After RGB values have been calculated the output file data can be written.

\subsection*{Creating Files}
For this task we have two options for creating a file:
\begin{enumerate}
\item Use command line output redirection
\item Use the C file I/O library
\end{enumerate}
The first option keeps your program simpler but requires the use of a command line when running the program. If your code simply uses \texttt{printf()} to output the PPM data (and \textit{nothing} else) it can be written to a file with:
\begin{lstlisting}[style=pseudo]
# ./a.out > image.ppm
\end{lstlisting}
The file \texttt{image.ppm} can then be downloaded (if you're using Che etc) or directly opened with an image editor. I know \texttt{eog}, \texttt{gimp}, etc open PPM on Linux and am naively hoping that something on Windows supports it.
\\~\\
The alternative, which will work with C development environments which don't have command lines like OnlineGDB, is to use the C file I/O library. To do this you need several lines of code and an extra function:
\begin{lstlisting}[style=CStyle]
FILE *output; // A pointer variable of type FILE*
output = fopen("image.ppm", "w"); // To open the file image.ppm
fprintf(output, "%d %d %d\n", r, g, b);
\end{lstlisting}
The \texttt{FILE *output} line is a variable declaration, only do this \textit{once}. Likewise, \texttt{output = fopen...} opens the file \texttt{image.ppm} for writing. Only do this \textit{once} as well.
\\~\\
The \texttt{fprintf()} function is almost exactly the same as \texttt{printf()} except it takes an extra argument: the file to write to. In this case passing \texttt{output} (the \texttt{FILE *} variable declared earlier) will write the formatted text to that file.

Lets see if somebody gets this to work given the above plus your own independent research. We will formally cover file I/O in a few weeks (check the course outline for a planned week).
\end{task}

\pagebreak 
\section{C Summary}
This section will be included in all future lab documents and lists a summary of C language features taught prior to the lab session. It will grow each week.

Not everything listed in this section is required to complete a particular lab.

\begin{multicols}{2}
\subsection{Basic Structure}
This is the absolute minimum amount of code you need to make a C program compile, run, and interact with the user via a console:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int main() {
	// Your program goes here
	return 0;
}
\end{lstlisting}
\subsection{Comments}
\begin{lstlisting}[style=CStyle]
// This is a comment to end of line

/* this is a block comment
   which could span
   multiple
   lines
   */
\end{lstlisting}

\subsection{Code Blocks}

Any section of code encompassed by \texttt{\{...\}} is a \textit{block}.

\subsection{Operators}\label{sec:operators}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
\hline
Operation      & C Symbol \\
\hline
Addition       & \texttt{+}        \\
Subtraction    & \texttt{-}        \\
Multiplication & \texttt{*}        \\
Division       & \texttt{/}       \\
Modulus		   & \texttt{\%}	\\
Increment	& \texttt{++}	\\
Decrement	& \texttt{--} \\
Less than       & $\texttt{<}$        \\
Less than or equal to    & $\texttt{<=}$\\
Greater than & $\texttt{>}$        \\
Greater than or equal to       & $\texttt{>=}$ \\
Equal to & \texttt{==} \\
Not equal to & \texttt{!=} \\
Boolean AND & \texttt{\&\&} \\
Boolean OR & \texttt{||} \\
Boolean NOT & \texttt{!} \\
\hline
\end{tabular}
\caption{Arithmetic operators in C}
\end{table}

\columnbreak
\subsection{Operator Shorthand}

Many arithmetic operators support the following shorthand syntax. The left and right columns present equivalent statements.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\texttt{x = x + y;} & \texttt{x += y;} \\
\texttt{x = x - y;} & \texttt{x -= y;} \\
\texttt{x = x * y;} & \texttt{x *= y;} \\
\texttt{x = x / y;} & \texttt{x /= y;} \\
\hline
\end{tabular}
\end{table}

\subsection{Data Types}\label{sec:datatypes}

\begin{table}[H]
\begin{tabular}{|l|l|l|l|}
\hline
Type & Bytes & Value Range                             \\
\hline
\texttt{char}      & 1                  & -128, +127  \\
\texttt{unsigned char}	& 1				& 0, 255 \\
\texttt{short}     & 2                & -32768, 32767\\
\texttt{unsigned short} & 2			& 0, 65535 \\
\texttt{int}       & 4                & $\approx \pm 2.1\times 10^9$ \\
\texttt{unsigned int}	& 4				& 0, 4294967296 \\
\texttt{long}      & 8                  & $\approx \pm 9.2\times 10^{18}$ \\
\texttt{unsigned long} & 8				& 0, $1.8 \times 10^{19}$ \\
\texttt{float}       & 4  & $1.2\times 10^{-38}$ to $3.4 \times 10^{38}$    \\
\texttt{double}      & 8  & $2.3 \times 10^{-308}$ to $1.7 \times 10^{308}$    \\

\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
Type & Precision \\
\hline
\texttt{float} & 6 sig. figs. \\
\texttt{double} & 15 sig. figs \\
\hline
\end{tabular}
\end{table}


\subsection{Standard i/o}

Read a single variable from \texttt{stdin} with \texttt{scanf();}
\texttt{scanf("\textit{format specifier}", \&\textit{variable}});

Write a single variable to \texttt{stdout} with \texttt{printf();}
\texttt{printf("\textit{format specifier}", \textit{variable});}

You can use \texttt{printf();} \textit{without} a newline (\texttt{\textbackslash n}) to create an input prompt:

\begin{lstlisting}[style=CStyle]
printf("Enter a number: ");
scanf("%d", &variable);
\end{lstlisting}

This prints:

\texttt{Enter a number: \_}

where \_ indicates the terminal prompt (ie: where typed characters will appear).

\subsection{Format Specifiers}
The following table is woefully incomplete. The compiler \textit{may} generate warnings if \texttt{\%d} is given something other than \texttt{int} and \texttt{\%f} is given something other than \texttt{float}. An attempt will be made to ensure these are sufficient.
\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
Data Type & Format Specifier \\
\hline
Integers & \texttt{\%d} \\
Floating point & \texttt{\%f} \\
Float with \texttt{n} decimal places & \texttt{\%.nf} \\
\hline
\end{tabular}
\caption{Basic format specifiers}
\end{table}

\subsection{Type Casting}
Placing the syntax \texttt{(\textit{type})} before a variable name performs a type cast (ie: data type conversion).

eg: convert \texttt{float} to an \texttt{int} prior to using its value. This forces a rounding-down to the nearest integer.

\begin{lstlisting}[style=CStyle]
float a;
// ...
y = (int)a * z;
\end{lstlisting}

\textbf{NB:} This does \textbf{not} modify the original variable.

Data type ``upgrades'' are done automatically by the compiler but sometimes it is desired to downgrade or force esoteric behaviour. Adding it unnecessarily doesn't have any negative impact. Applications in ENGG1003 will be limited but it comes up regularly in embedded systems and nobody else explicitly teaches type casting. I have used it extensively in the low-level art of \textit{bit banging}: manual manipulation of binary data. This is, unfortunately, beyond ENGG1003.

\subsection{Flow control}

Flow control allows selected blocks of code to execute multiple times or only under a specified condition.

\subsubsection{\texttt{if()}}\label{sec:if}

The \texttt{if()} statement executes a block of code only if the \textit{condition} is true. The condition is an arithmetic statement which evaluates to either zero (false) or non-zero (true).

\texttt{if()} Syntax:

\texttt{if(\textit{condition}) \{/* other code */\}}

\columnbreak
Full \texttt{if()} example:

\begin{lstlisting}[style=CStyle]
if(x > 10) {
	// Do stuff
}
\end{lstlisting}

Condition Examples:
\begin{itemize}
\item \texttt{if(x) // if(x is not zero)}
\item \texttt{if(x+y) //if((x+y) is not zero)}
\item \texttt{if(y >= 5)}
\item \texttt{if(1) // Always executes}
\item \texttt{if(0) // Never executes}
	\begin{itemize}
		\item Can be used for debugging. Might be easier than a block comment /* */
	\end{itemize}
\end{itemize}

\textbf{NB:} \textit{NEVER} place a semicolon after an \texttt{if()}, that stops it from having any effect. The block after it will always execute. This bug can take days to find.

If there is only \textit{one} statement after an \texttt{if()} the \{ \} braces are optional:

\begin{lstlisting}[style=CStyle]
if(x > 10) 
	printf("x is greater than 10\n");
\end{lstlisting}


\subsubsection{\texttt{if() ... else if()}}

The C syntax for IF ... ELSE is:

\begin{lstlisting}[style=CStyle]
if(condition) {
	// Do stuff
} else {
	// Do stuff
}
\end{lstlisting}

IF ... ELSEIF takes the form:

\begin{lstlisting}[style=CStyle]
if(condition) {
	// Do stuff
} else if(condition) {
	// Do stuff
}
\end{lstlisting}

Multiple ``layers'' of \texttt{else if()} can be written. You don't have to stop at two.

\textbf{NB:} \textit{NEVER} place a semicolon directly after  the \texttt{else if()}. Semicolons only go after the statements inside the \texttt{if()} block (ie: between the curly braces \{ \}).

\columnbreak
\subsubsection{\texttt{while()}}

The \texttt{while()} flow control statement executes a block of code so long as a condition is true. The condition is checked before the block is executed and before every repeated execution.

The condition rules and examples are the same as for those listed under the \texttt{if()} statement.

Syntax:

\texttt{while(\textit{condition)} \{/* other code */\}}

Example:

Evaluate the infinite sum:
\begin{equation}
\sum_{n=0}^{\infty} \frac{1}{n^2}
\end{equation}
to a precision of $1 \times 10^{-6}$
\begin{lstlisting}[style=CStyle]
float sum = 0.0;
int x = 0;
while(1/(x*x) > 1e-6) {
	sum = sum + 1.0/(x*x);
	x++
}
\end{lstlisting}

\textbf{NB:} \textit{NEVER} place a semicolon directly after a \texttt{while()} line. Semicolons only go after the statements inside the loop.

\subsubsection{\texttt{for(;;)}}\label{sec:for}

\textit{As of week 2 this has not yet been covered in lectures.}

The \texttt{for(;;)} loop syntax is:

\begin{lstlisting}[style=CStyle]
for( initial ; condition ; increment ) {
	// Do stuff
}
\end{lstlisting}

The three sub-parts have the following behaviour:

\begin{itemize}
\item \textbf{Initial:} Code which is executed \textit{once}, before the loop is entered
\item \textbf{Condition:} A condition which is tested \textit{before} every loop iteration
\item \textbf{Increment:} Code which is executed \textit{after} every iteration
\end{itemize}

\texttt{for(;;)} Example:

\begin{lstlisting}[style=CStyle]
int x;
for( x = 0 ; x < 10 ; x++ ) {
	printf("%d ", x);
}
\end{lstlisting}

will print:

\texttt{0 1 2 3 4 5 6 7 8 9}

The \texttt{for(;;)} loop example doesn't print \texttt{10} because the condition is ``strictly less than 10''. When x is incremented to 10 the condition fails and the loop exits. It prints 0 because the increment is only applied \textit{after} the loop has run once.

\subsubsection{\texttt{switch() case:}}

The \texttt{switch() case:} statement is a flow control mechanism which allows one option from a list of many to be executed. It is a neater replacement from complicated \texttt{if() else if()} blocks.

Example:

\begin{lstlisting}[style=CStyle]
switch(x) {
	case 1: // Jumped to if x == 1
		break; // Jump out of switch()
 	case 2: // Jumped to if x == 2
		break;
	case 3: // Jumped to if x == 3
		break;
	default:	// Jumped to if nothing else matched
}
\end{lstlisting}


\subsection{Library Functions}
\subsubsection{\texttt{rand()}}

To generate a random number between \texttt{0} and \texttt{MAX}:

\begin{lstlisting}[style=CStyle]
#include <stdlib.h> // For rand()
// ...
x = rand() % (MAX + 1);
\end{lstlisting}

For all work in this course you may assume that the above method works well enough.

For more crucial work (eg: cryptography, serious mathematics) this method is considered problematic. Very advanced discussion \underline{\href{http://www.azillionmonkeys.com/qed/random.html}{Here}}.

\subsection{Glossary of Terms}

\textit{I'll sort these alphabetically later, just a brain dump for now. Sorry.}

\begin{itemize}
\item \textbf{Compiler:} The software package which converts \textit{source code} into a \textit{binary}.
\item \textbf{Source Code:} The text which you type into a programming environment (eg: OnlineGDB) which is sent to the \textit{compiler}.
\item \textbf{Binary:} A program data file which can be executed on a computer.
\item \textbf{Variable:} A ``thing'' which remembers a number within your program. In C they have a \textit{type}, a name, (optionally) an initial value, and (for future reference) a \textit{memory address}. Variables change when they are on the left side of an \textit{assignment}.
\item \textbf{Pseudocode:} Any hand-written or typed notes which document the behaviour of a computer program. Pseudocode is for humans to read, not computers.
\item \textbf{Flow Control:} Any algorithmic statement which breaks the ``top-to-bottom, line-by-line'' execution pattern of a computer program.
\columnbreak
\item \textbf{Statement:} A line of C code which performs a task and ends with a semicolon. Arithmetic lines, \texttt{printf();}, \texttt{scanf();}, and \texttt{rand();} are all examples of statements.
\item \textbf{Assignment:} The process of changing a variable's value as your program executes. In C, this is typically performed with the \texttt{=} symbol. Eg: \texttt{x = y + 5} calculates the value of ``\texttt{y + 5}'' then allocates the result to the variable \texttt{x}.
\item \textbf{Block:} A section of code ``grouped together'' by curly braces \{ ... \}. Typically applies to flow control, where a single, say, \texttt{if()} controls a block of code listed inside \{ and \}.
\item \textbf{Literal:} Any numerical constant written in your code. Eg: In \texttt{x < 2.0} the ``\texttt{2.0}'' is a literal. Unless otherwise stated, integer literals are treated as \texttt{int} data types (ie: they inherit the \texttt{int}'s value range limit) and real valued literals are treated as \texttt{double}s.
\end{itemize}

\end{multicols}

\end{document}
