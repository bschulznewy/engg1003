\documentclass{lab}

\usepackage{graphicx}
\usepackage{float}
\usepackage{soul}
\usepackage{multicol}

\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}

\title{ENGG1003 - Lab Week 5}
\author{Brenton Schulz}
\date{\today}

\begin{document}
\maketitle

\section{Pre-Reading}
Read through the following textbook sections:

\begin{itemize}
\item Section 2.4 Random Numbers: \url{https://link.springer.com/chapter/10.1007/978-3-030-16877-3_2#Sec23}
\item Section 3.3.4 Example: Random Walk in Two Dimensions: \url{https://link.springer.com/chapter/10.1007/978-3-030-16877-3_3#Sec10}
\end{itemize}

\pagebreak

\section{Revision - Summations and \texttt{for} Loops}

The Week 3 lab included Exercise 3.11 from the textbook. This exercise requires an ``infinite sum'' to be evaluated of the form:

\begin{equation}\label{eq:pi}
\pi = 8 \sum_{k=0}^{\infty}\frac{1}{(4k+1)(4k+3)}
\end{equation}

Breaking down this notation:
\begin{itemize}
\item $\Sigma$ means ``sum''
\item $k=0$ below the $\Sigma$ means that $k$ is a \textit{variable} which takes integer values starting at zero
\item $\infty$ above the $\Sigma$ means that there is no limit to how large $k$ can become
\item Each value of $k$ gets substituted into the $\frac{1}{(4k+1)(4k+3)}$ expression and all results added together
\item ``$\pi=$'' implies that the sum will approach $\pi$ as $k$ approaches $\infty$
\end{itemize}

Putting it all together, the first few terms of Equation \ref{eq:pi} can be written out as:

\begin{equation}
\frac{1}{(4\times 0 + 1)(4 \times 0 + 5)} + \frac{1}{(4\times 1 + 1)(4 \times 1 + 5)} + \frac{1}{(4\times 2 + 1)(4 \times 2 + 5)} + ...
\end{equation}

It turns out that expressions of this form map quite cleanly to \texttt{for} loops when programming:

\begin{itemize}
\item An expression is evaluated multiple times for different values of one variable
\item A \texttt{sum} variable can ``accumulate'' calculations inside the loop in the form \texttt{sum = sum + <something>}
\item $k$ as the ``summation variable'' becomes the ``loop variable'' \texttt{k}
	\begin{itemize}
		\item Pay close attention to the starting value of \texttt{k=0}
		\item Computer's can't count to $\infty$, so choose a ``reasonable'' value of, say, 100 000 for the final value of \texttt{k}
	\end{itemize}
\item The $\frac{1}{(4k+1)(4k+3)}$ expression becomes the Python expression \texttt{1/((4*k+1)*(4*k+3))} (note double level nesting of \texttt{( ()() )} in the denomenator - without the outer \texttt{( )} the expression becomes $\frac{4k+3}{4k+1}$.
\end{itemize}

\begin{task}{Python Implementation of Equation \ref{eq:pi}}{}
Given all the above, write a Python script which implements Equation \ref{eq:pi} for \texttt{k=0} to \texttt{k=99} (ie: with \texttt{range(0,100)}.
\\~\\
Remember to multiply the result of the summation by 8 to get an approximation of $\pi$!
\\~\\
The final value should be \texttt{3.13659}.
\\~\\
If you get \texttt{0.39207} the multiply by 8 was omitted.
\\~\\
Once your code is correct repeat the calculation with \texttt{range(0,100000)} to get the more accurate result of \texttt{3.141587}.
\end{task}

\pagebreak
\section{Random Numbers}
\begin{task}{Simplified Random Walk}{}
Section 3.3.4 of the textbook shows a ``random walk'' program which randomly moves a point N, S, E, or W 1000 times.
\\~\\
In this task you will repeat this problem with floating point steps. ie: the x and y movements will be drawn from a uniform distribution using \texttt{np.random.uniform()}. This will make the simulation roughly analogous to brownian motion - the movement of particles in a liquid or gas.
\\~\\
The program is to fill in two \texttt{numpy} arrays: one of x locations and one of y. The array index will then become a ``time'' variable. This will allow the simulation results to be plotted with \texttt{plot(x,y)}.
\\~\\
Write a Python script which implements the follow pseudocode to move a point around randomly and plot the result:
\begin{lstlisting}
BEGIN
	N = 1000
	x = an array of N zeros
	y = an array of N zeros
	FOR each element, n, in x and y from 1 to N:
		x[n] = x[n-1] + a random float from [-1,1)
		y[n] = y[n-1] + a random float from [-1,1)
	ENDFOR
	plot the set of x-y points, drawing lines between points
END
\end{lstlisting}
You may call \texttt{np.random.uniform()} within the loop or create a pair of additional arrays containing random numbers before entering the loop.
\end{task}

\pagebreak
\section{The CSV Format}

As seen in lectures, we will be studying the use of the \texttt{pandas} library for reading CSV (comma separated value/variable) files.

The CSV format allows for ``spreadsheet'' data to be stored as ``human-readable'' ASCII text. Column headings and numerical values are written as plain text and columns are separated by commas\footnote{Some variations allow for space or tab separation while still being classed as ``CSV'' files.}. Rows are separated by new lines.

\begin{task}{Opening CSV Files}{}
This lab will make use of a real scientific dataset from the Bureau of Meteorology. The Bureau of Meteorology makes a vast amount of climate data available online here: \url{http://www.bom.gov.au/climate/data/index.shtml}
\\~\\
You are welcome to browse data as it suits your interest but this lab will make use of the monthly rainfall data for the Nobbys Signal Station weather station on the coast of Newcastle.
\\~\\
Download the \texttt{zip} containing the above \texttt{csv} data from here:\\~\\ \url{http://www.bom.gov.au/jsp/ncc/cdio/weatherData/av?p_display_type=monthlyZippedDataFile&p_stn_num=061055&p_c=-745551072&p_nccObsCode=139&p_startYear=}
\\~\\
Unzip the file and open the three included files in a \textbf{text editor}. The lab computers have Notepad++ installed but you could also use Notepad or, at worst, open them in PyCharm.
\\~\\
Observe the ``human readable'' nature of the \texttt{csv} format. You may wish to keep this file open for debugging purposes.
\\~\\
Observe that the same rainfall data is provided in two layouts:\\
\begin{itemize}
\item \texttt{IDCJAC0001\_061055\_Data1.csv} contains one row per month with the \texttt{Year} and \texttt{Month} columns indicating which month (from Janurary 1862 to Feburary 2021) the rainfall figure is from
\item \texttt{IDCJAC0001\_061055\_Data12.csv} contains a 2D grid where the row indicates a year and column indicates a month.
\end{itemize}
~\\
Note that there are several \texttt{null} values in the file ending \texttt{\_Data12.csv}. These are missing data points. Missing data in \texttt{\_Data1.csv} is indicated with missing rows where adjacent year/month combinations are discontinuous (eg: It jumps from \texttt{1864,08} to \texttt{1867,01}).
\end{task}

In this course we will use the \texttt{pandas} library to read \texttt{csv} files. Before it can be used you must run \texttt{pip install pandas} to install it.

\pagebreak
\begin{task}{Reading and Analysing Rainfall Data}{}
This task is presented in multiple parts and is presented in a more ``real'' style compared to previous lab tasks. You are welcome to discuss problem solving strategies with your lab peers as well as demonstrators.
\\~
\begin{enumerate}
\item Write a Python script which uses \texttt{pandas} to open either of the provided \texttt{csv} files and produces a single \texttt{numpy} array of monthly rainfall data.
\\~\\
Your array should be 1910 elements. Data is provided from Janurary 1862 to Feburary 2021 which is $159\times 12 = 1908$ months plus Janurary and Feburary 2021 $=1910$ data points.
\\~\\
See Slide 18f of the Thursday Week 4 lecture slides for a \texttt{pandas} example. The recording timestamp is: \url{https://www.youtube.com/watch?v=GZmJTGqh5pw#t=50m45s}
\\~\\
Note that \texttt{null}, or missing, data should, be stored in your array as a value of -1. Since negative rainfall is physically impossible this value unambiguously indicates missing data as opposed to, say, zero rainfall.
\\~\\
Depending on which file you choose to read from different challenges will arise. For example, \texttt{\_Data1.csv} contains missing rows so you can't simply copy the rainfall data column to an array - the index of the array must be calculated from the year and month columns. If you read from the ``2D grid'' format you will need to make special provisions for the \texttt{null} values.

\item Plot the timeseries data, leaving missing values as -1. A simple \texttt{plot(rainfall)} will suffice here as we are visulising the data for development purposes - not producing a plot for publication.

\item Plot a \textit{histogram} of the monthly rainfall data. To do this you can use the \texttt{plt.hist()} function from \texttt{matplotlib.pyplot}. If the data is stored in the \texttt{numpy} array \texttt{rainfall} then the histogram can be plotted with:

\begin{lstlisting}
plt.hist(rainfall)
plt.show()
\end{lstlisting}

\item Summary statistics for Nobbys Signal Station are provided by the BOM at the bottom of this page: \url{http://www.bom.gov.au/jsp/ncc/cdio/weatherData/av?p_nccObsCode=139&p_display_type=dataFile&p_startYear=&p_c=&p_stn_num=061055}

From your data, calculate the mean, lowest, and highest rainfall figures for each month and compare them with BOM's calculations.
\\~\\
Note that the \texttt{\%} (modulus) operator may be useful when converting an array index to a month. ie: the index modulo 12 will provide a month number where 0 is Janurary and 11 is December.

\item Because the data is missing values we will make some effort to take a ``best guess'' and fill them in. The timeseries plot would have shown that rainfall data is very random so a technique such as linear interpolation is not appropriate - we need a method based in statistics.
\\~\\
Fill in the missing data with one twelth of the annual mean figure as reported by the BOM. This is 1118 / 12 = 93mm.

\item Plot the histogram of the ``filled in'' data. Does it look like the technique above works or have you, say, created false lumps in the histogram?

\item Fill in all missing figures with the mean of that month for all years. ie: if a \texttt{null} occurs in Janurary fill it in with 88.7~mm.
\\~\\
Re-plot the histogram. Is this method any better? Does the histogram look ``smoother''?

\end{enumerate}
\end{task}


\end{document}
