\documentclass{lab}

\usepackage{graphicx}
\usepackage{float}
\usepackage{soul}
\usepackage{multicol}

\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}

\title{ENGG1003 - Lab 3}
\author{Brenton Schulz}
\date{\today}

\begin{document}
\maketitle

\begin{itemize}
\item arrays, indexing, slicing
\item for loops
\item boolean expressions / relational operators
\item if statements
\item while loops
\end{itemize}

\begin{task}{Pre-Lab Reading}{}
Read Sections 2.1 and 2.2 of the textbook: \url{https://link.springer.com/chapter/10.1007/978-3-030-16877-3_2}
\\~\\
These sections provide general background information which will help you write Python scripts with confidence. The content is best learned ``by immersion''. All the details covered in these sections will be constantly used throughout your programming career.
\end{task}

\section{Arrays}

\begin{task}{Array Background Reading}{}
Read Section 2.3 of the textbook, stopping at 2.3.6. Execute examples as you go.
\\~\\
Direct link: \url{https://link.springer.com/chapter/10.1007/978-3-030-16877-3_2#Sec16}
\\~\\
You are welcome to read 2.3.6 (regarding 2D arrays) but that content will be covered later.
\end{task}

\begin{task}{Fibonacci  Sequence - Naive Implementation}{}
The Fibonacci sequence is a sequence of numbers, $x_0$, $x_1$, $x_2$, ... etc, with the following equation used to calculate $x_n$ given $x_{n-1}$ and $x_{n-2}$:

\begin{equation}\label{eq:fib}
x_n = x_{n-1} + x_{n-2}
\end{equation}

Write a Python script which, given $x_0=1$ and $x_1=1$, calculates and prints the next 8 values of the Fibonacci sequence.
\\~\\
To do this, create a NumPy array, \texttt{fib[]} containing 10 zeros, manually assign the above 1's to \texttt{fib[0]} and \texttt{fib[1]}, then write out the equation as follows for the next 8 values:
\begin{lstlisting}
fib[2] = fib[1] + fib[0]
fib[3] = fig[2] + fib[1]
... etc
print(fib)
\end{lstlisting}

Note that there is a far more efficient method using \textit{loops}. This will be explored later.
\end{task}

\section{\texttt{for} Loops}

As seen in the previous section computers are able to perform the same calculation repeatedly but doing so with multiple copies of the expression is tedious and error prone.

The \texttt{for} loop is a programming \textit{flow control} concept where a block of code is repeated a set number of times. Typically the number of repeats must be known at the time the loop executes.

\begin{task}{\texttt{for} Loops - Reading}{}
Read Section 3.1 of the textbook: \url{https://link.springer.com/chapter/10.1007/978-3-030-16877-3_3#Sec1}
\end{task}

\begin{task}{Fibonacci Sequence with a \texttt{for} Loop}{}
Modify your Fibonacci sequence script to utilise a \texttt{for} loop and the \texttt{range()} function. Note that by utilising a \texttt{for} loop you now only need to write out Equation \ref{eq:fib} \textit{once}, irrelevant of how many values you wish to calculate.
\\~\\
A few notes \& tips:
\begin{itemize}
\item Try to use a single variable \texttt{N} which specifies how many values to calculate
\item Since the first calculation is giving the 3rd value the \texttt{range()} function needs to be called as \texttt{range(2,N)}.
\item If \texttt{N} is large (more than about 90) care must be taken with the choice of data type. \texttt{np.zeros()} will, by default, create \texttt{np.float64}s but the Fibonacci sequence is intrinsically an \textit{integer} sequence. Experiment with different datatypes specified in the call to \texttt{np.zeros()}. eg: \texttt{fib = np.zeros(N,dtype=np.uint64)}\\~\\The full list of NumPy datatypes is here: \url{https://numpy.org/devdocs/user/basics.types.html}. How many terms can you calculate before an ``overflow'' error with \texttt{uint8}, \texttt{uint32}, and \texttt{uint64}?
\item \texttt{print(fib)} should print the entire array but you can call \texttt{print()} from within the loop so that only a single value is printed on each line.
\end{itemize}
\end{task}

\section{\texttt{while} Loops}

Contrasting with a \texttt{for} loop the \texttt{while} loop allows a block of code to be executed multiple times without the need for the repetition count to be known when the loop starts.

\begin{task}{\texttt{while} Loops - Reading}{}
Read Section 3.2 of the textbook: \url{https://link.springer.com/chapter/10.1007/978-3-030-16877-3_3#Sec7}
\end{task}

\begin{task}{Fibonacci Sequence with \texttt{while} Loops}{}
Fork your Fibonacci sequence code (ie: save a copy of it so it can be loaded later).
\\~\\
Using a \texttt{while} loop, implement a Fibonacci sequence generator which prints the Fibonacci sequence until the printed value exceeds 1 million.
\\~\\
You will need to compare the last printed value with the constant \texttt{1000000}. Assuming arrays are still used, you will also need to manually increment (and initialise) the variable used to index the array.
\end{task}

\section{\texttt{if} Statements}

\begin{task}{\texttt{if} Statement Reading}{}
Read Section 3.3 of the textbook, stopping at Section 3.3.4: \url{https://link.springer.com/chapter/10.1007/978-3-030-16877-3_3#Sec10} 
\end{task}

\begin{task}{Testing Divisibility}{}
In Python (and many other languages) the \texttt{\%} symbol is used as the \textit{modulo} operator. It provides the remainder of the division between two integers.
\\~\\
An integer $a$ is said to be divisible by another integer $b$ if \texttt{a \% b} is zero. In Python, such a divisibility test can be implemented with an \texttt{if} statement as:
\\~\\
\texttt{if a \% b == 0:}
\\~\\
Write a Python script which tests all integers between 1 and 100 for divisibility by both 3 and 5. When an integer is divisible by 3 print ``\texttt{n} is divisible by 3'' and similarly for when an integer is divisible by 5.
\\~\\
\textbf{Extension:} If an integer is divisible by both 3 and 5 print ``Bingo!''. A program which performs these three divisibility tests is commonly known as ``fizz-buzz'' and is a frequently used test in job interviews. There is extensive discussion about various implementations and optimisations online.
\end{task}

\section{Further Exercises}

\begin{task}{Fibonacci Sequence Without Arrays}{}
Modify either the \texttt{for} or \texttt{while} loop Fibonacci sequence code so that instead of using an array it calculates the sequence using only 3 variables:
\\~
\begin{itemize}
\item \texttt{xn} - The current value
\item \texttt{xnm1} - The previous value, $x_{n-1}$
\item \texttt{xnm2} - The value of $x_{n-2}$
\end{itemize}
~\\
The calculation needs to be performed in two steps:
\\
\begin{enumerate}
\item Calculate the current value, $x_n$
\item ``Move forward in time'' by executing \texttt{xnm2 = xnm1} and \texttt{xnm1 = xn}.
\end{enumerate}
~\\
Note that you can use other variables (eg, \texttt{N} for the number of terms to calculate) but the array which previously stored the sequence must not be used.
\\~\\
This implementation has the advantage of using \textit{significantly} less RAM than the array-based version. The disadvantages are that you must print each value as it is calculated and the code is potentially less ``readable'' - it looks less like Equation \ref{eq:fib} than the array based versions.
\end{task}

\begin{task}{Quadratic formula}{}
In Week 1 lectures the following algorithm was presented for finding the roots of a quadratic:
\begin{lstlisting}[style=pseudo]
BEGIN
        INPUT: a, b, c
        D = b**2 - 4ac
        IF D < 0
                 N = 0
        ELSEIF D == 0
                N = 1
                x1 = -b/(2a)
        ELSEIF D > 0
                N = 2
                x1 = (-b + sqrt(D))/(2a)
                x2 = (-b - sqrt(D))/(2a)
        ENDIF
        OUTPUT: N, x1, x2
END
\end{lstlisting}
Write a Python script which implements this algorithm and prints any solutions found. If no (real valued) solutions exist print a message to the user saying as such.
\\~\\
You may initialise the variable \texttt{a}, \texttt{b}, and \texttt{c} or, if you know how, read them from the console.
\end{task}

\pagebreak
\begin{task}{Calculating Square Roots}{}
The square root of a number, $x = \sqrt{n}$, can be calculated with the iterative formula:
\begin{equation}\label{eq:sqrt}
x_{k+1} = \frac{1}{2}\left(x_k + \frac{n}{x_k}\right)
\end{equation}
Write a Python script which implements this formula to calculate square roots of real numbers. Initialise $x_0$ to a random (non-zero) value of your choosing.
\\ \\
The algorithm should be implemented with a loop. The loop's design condition could be one of several choices, in order of difficulty:\\
\begin{enumerate}
\item A \texttt{for} loop with a fixed number of iterations (eg: 10)
\item A \texttt{while} loop which exits when $\left| x_k - x_{k-1} \right| < e$ where $e$ is some pre-defined precision of your choosing (eg, 1 millionth = \texttt{1e-6})
\item A \texttt{while} loop which exists when either of the above conditions are met
\end{enumerate}
~\\
To calculate precision you will need to explicitly save $x_k$ and $x_{k-1}$ in different variables.
\\~\\
\textbf{Hint:} You can place \texttt{print()} statements inside the loop to help you debug. Calculate the series of $x_n$'s for a particular value (eg: $\sqrt{2}=1.4142$) by hand (with the same value for $x_0$) so that you can compare your program's output with an output you have confidence in.
\end{task}\label{tsk:sqrt}

\begin{task}{Textbook Exercise: Calculating $\pi$}{}
Complete exercise 3.11 from the textbook.
\\~\\
Section link: \url{https://link.springer.com/chapter/10.1007/978-3-030-16877-3_3#Sec15}
\end{task}

\end{document}
