\documentclass[14pt]{beamer}
\usetheme{Dresden}
\usecolortheme{orchid}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm2e}
\usepackage{multicol}
\usepackage{amssymb}

\usefonttheme[onlymath]{serif}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.8,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\definecolor{lightBlue}{rgb}{0.1, 0.1, 0.8}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\lstdefinestyle{Ctable}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\lstdefinestyle{pseudo}{
        basicstyle=\ttfamily\footnotesize,
        keywordstyle=\color{lightBlue},
        morekeywords={BEGIN,END,IF,ELSE,ENDIF,ELSEIF,PRINT,WHILE,RETURN,ENDWHILE,DO,FOR,TO,IN,ENDFOR,BREAK,INPUT,READ},
        morecomment=[l]{//},
        commentstyle=\color{mGreen}
}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt,tabsize=2}

\title{ENGG1003 - Friday Week 4}
\subtitle{Functions\\Static Variables\\Commenting\\Arrays (but probably not)}
\author{Brenton Schulz}
\institute{University of Newcastle}
\date{\today}


\begin{document}
\titlepage

\begin{frame}[fragile]
\frametitle{Writing Functions - Example}

\begin{itemize}
\item Lets view a few common errors
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
float mySqrt(float k);
int main() {
	printf("%f\n", mySqrt(26));
}
\end{lstlisting}
\item Results in:
\begin{lstlisting}[style=pseudo]
/tmp/ccT6mLDi.o: In function `main':
/projects/voidTest/hello.c:4: undefined reference to `mySqrt'
collect2: error: ld returned 1 exit status
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Writing Functions - Example}
\begin{itemize}
\item Likewise, forgetting the prototype:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int main() {
	printf("%f\n", mySqrt(26));
}
\end{lstlisting}
\item Results in (cut down):
\begin{lstlisting}[style=pseudo]
hello.c: In function `main':
hello.c:4:17: warning: implicit declaration of function 'mySqrt'
  printf("%f\n", mySqrt(26));
/projects/voidTest/hello.c:4: undefined reference to `mySqrt'

\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Function Compiler Errors}
\begin{itemize}
\item ``implicit declaration of...''
	\begin{itemize}
		\item The function prototype is missing
	\end{itemize}
\item ``undefined reference to...''
	\begin{itemize}
		\item The function definition is missing
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Function Definition Placement}
\begin{itemize}
\item The following \textit{works} but isn't recommended:
\begin{lstlisting}[style=CStyle,basicstyle=\ttfamily\scriptsize]
#include <stdio.h> 
#include <math.h> 

float mySqrt(float k) { 
	int n; 
	float xn = k/2.0; 
	for(n = 0; n < 10; n++) 
		xn = 0.5*(xn + k/xn); 
	return xn; 
}

int main() { 
	printf("sqrt(26) = %.8f\n", mySqrt(26.0)); 
	printf("Library sqrtf(26): %.8f\n", sqrtf(26.0)); 
}
\end{lstlisting}
\item Only useful in very small projects but common
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Function Arguments}
\begin{itemize}
\item Function arguments automatically become variables inside the function
\begin{lstlisting}[style=CStyle]
float mySqrt(float k) {  // k is an argument
	int n; 
	float xn = k/2.0;  //k used here
	for(n = 0; n < 10; n++) 
		xn = 0.5*(xn + k/xn); // and here
	return xn; 
}
\end{lstlisting}
\item Don't declare them as variables!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Function Arguments}
\begin{itemize}
\item By default, arguments are ``passed by value''
\item The function gets \textit{copies}
\item Modifying them in a function doesn't change the original variable
	\begin{itemize}
		\item No, not even if they have the same name
	\end{itemize}
\item The argument variables are discarded on function return
\item The return value is the \textit{only thing} that goes back
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Function Return Values}
\begin{itemize}
\item Return values can only be one number
\item How can we write a function which modifies (or returns) multiple things?
\pause
\item Trigger warning....
\pause
\item Pointers!
\pause
\item We'll learn how to use pointers in Week 6(ish)
\item For now, just learn to live with the single return value
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Function Example}
Write a C function, \texttt{isPrime()}, which takes an \texttt{int} as an argument and returns 1 if it is prime and zero otherwise
\begin{itemize}
\item Name: \texttt{isPrime}
\item Argument(s): \texttt{(int x)}
\item Return Value: \texttt{int}
\pause
\item Function prototype: \texttt{int~isPrime(int~x);}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Function Example}
\begin{center}
... Do it live in Che without preparation.\\~\\Future Brenton might regret this but Present Brenton don't care.
\end{center}
\end{frame}

\begin{frame}
\frametitle{Static Vs Auto Variables}
\begin{itemize}
\item Any ``normal'' variable declared within the function (including arguments) is lost on function exit
	\begin{itemize}
		\item These are called \textit{auto} variables
	\end{itemize}
\item By default, any declared variable is an auto variable
	\begin{itemize}
		\item Their value is lost outside the block where they are declared
	\end{itemize}
\pause
\item Alternatively, \texttt{static} variables can be used
 \begin{itemize}
 	\pause
 	\item Their value is retained
 	\pause
 	\item Their scope is still limited
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Static Variables}
\begin{itemize}
\item Example: the \texttt{rand()} function returns different random numbers each time it is called
	\begin{itemize}
		\item How? Shouldn't everything be lost when the function returns?
		\item Not always! The \texttt{rand()} function's ``state'' is kept by a \texttt{static} variable.
	\end{itemize}
\pause
\item Variables are static if declared with the \texttt{static} keyword
\item Declaration examples:
\pause
{\small
\item \texttt{static int k = 0;}
\item \texttt{float z = 0, static y = 0;}
\item \texttt{static long bigNum = 2345235234432;}
}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Static Variable Example}
\begin{itemize}
\item Example: Write a function, \texttt{counter()} which returns an integer equal to the number of times it has been called.
\pause
\item Function prototype: \texttt{int counter(void);}
\pause
\item Function definition:
\begin{lstlisting}[style=CStyle]
int counter() {
	static int count = 0;
	return count++;
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Static Variable Example}
\begin{itemize}
\item The variable \texttt{count} is declared \texttt{static}
\item The initialisation, \texttt{count = 0}, happens \textit{once}
\item The value of \texttt{count} is retained between function calls 
\begin{lstlisting}[style=CStyle]
int counter() {
	static int count = 0;
	return count++;
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Static Variable Example}
\begin{itemize}
\item Wait, why would you do this?
\pause
\item The function can be called from \textit{anywhere} in your code
\pause
\item A ``counter'' variable that did the same job would have to be ``global'' to be visible anywhere
	\begin{itemize}
\pause
		\item For multiple reasons we try to avoid variables with global scope
			\begin{itemize}
				\item Good discussion \underline{\href{http://wiki.c2.com/?GlobalVariablesAreBad}{here}}
			\end{itemize}
\pause
		\item There are \textit{very good} reasons to use them in embedded systems, but not on a desktop PC or server
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Static Variable Example}
Wrapping the function in some test code:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>

int counter(void);

int main() {
	for(int k = 0; k < 10; k++)
		printf("counter(): %d\n", counter() );
	return 0;
}

int counter(void) {
	static int count = 0;
	return count++;
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Test Code?}
\begin{itemize}
\item ``Test code'' is a term I made up
\item It means the minimum amount of code required to verify a function's behaviour
\item Always test your functions \textit{in isolation}!
\pause
\item If you write ``too much'' code before testing it will make debugging \textbf{much} harder
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Test Code}
\begin{itemize}
\item How much is ``too much''?
\pause
\item Personally?
\pause
\item After 20 years of experience?
\pause
	\begin{itemize}
		\item 1-5 lines
	\end{itemize}
\pause
\item Never underestimate:
	\begin{itemize}
		\item How hard programming is
		\item How easy it is to make mistakes
		\item How \textit{brutally catastrophic} bugs can be
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Bug Case Study}
Paraphrased from \underline{\href{https://en.wikipedia.org/wiki/Therac-25}{Wikipedia}}:
\\~\\
``The Therac-25 was a computer-controlled radiation therapy machine ... It was involved in at least six accidents ...  in which patients were given massive overdoses of radiation. Because of concurrent programming errors, it sometimes gave its patients radiation doses that were hundreds of times greater than normal, resulting in death or serious injury.''
\end{frame}

\begin{frame}
\frametitle{Back to Functions...}
\begin{itemize}
\item When should functions be used?
\pause
\item Well, what do they achieve?
	\begin{itemize}
		\item \textit{Much} easier to solve problems when they're broken down into sub-tasks
		\item Reduce code line count and complexity (if they are called multiple times)
		\item Allows code re-use between projects
		\item \textit{Much} easier to perform project management between multiple programmers
		\item Bugs in a function are easier to fix than a bug in code which has been copy+pasted multiple times
		\item ...the list goes on
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{When should functions be used?}
\begin{itemize}
\item What about in an ENGG1003 context?
\pause
	\begin{itemize}
		\item Vague rule of thumb? No more 10-20 lines or so in one block.
		\item Break a big problem into multiple sub-problems
			\begin{itemize}
				\item Implement each as their own function
				\pause
				\item Yes, even if they are only called once
				\pause
				\item Do what you feel is most ``readable''
				\pause
				\item Your opinion here will change with experience, I will try to provide guidance
			\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Functions and Comments}
\begin{itemize}
\item Programming courses always tell you to comment your code
\item But what is ``good'' commenting?
\item Lets look at some examples:
\pause
	\begin{itemize}
		\item From the \underline{\href{https://raw.githubusercontent.com/torvalds/linux/master/kernel/async.c}{Linux kernel source}}
		\pause
		\item From an \underline{\href{http://libopencm3.org/docs/latest/stm32f4/html/adc_8c_source.html}{embedded systems library}}
	\end{itemize}
\pause
\item Just a little different from each other, eh?
\item Commenting is very application specific
\item Commenting is very audience specific
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Commenting in ENGG1003}
\begin{itemize}
\item How many comments do we use in ENGG1003?
\item On one hand: only comment what \textit{you} need
\item On the other: we need to assess your comments eventually...
\pause
\item And the assessment needs to minimise demonstrator judgement...
\pause
\item Maybe I create different strict rules for different assignments? Similar to ENGG1500 report rules.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Arrays}
\begin{itemize}
\item Anyway, new topic!
\item So far: all variables have been a \textit{single} number
\item What do you do if you need a million of them?
\pause
\item Declare a million variables?
\pause
\item Cry?
\pause
\item Use an \textit{array}!
\pause
	\begin{itemize}
		\item Maybe still cry...at first.
	\end{itemize}
\pause
\item An \textit{array} is a collection of variables of the same data type
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Arrays}
\begin{itemize}
\item Remember the mathematics notation:
\begin{equation*}
x_0, x_1, x_2, x_3, ...
\end{equation*}
\item We used it for a single variable, $x$, changing with time
	\begin{itemize}
		\item The ``old'' values of $x$ were discarded
	\end{itemize}
\pause
\item An array allows us to store \textit{all} the values of $x_n$ in memory
\item The variable name, $x$, and the ``index'', $n$, are both needed to access a particular value
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Arrays}
\begin{itemize}
\item In C, an array declaration \textbf{needs} three things:
	\begin{itemize}
		\item The data type
		\item A name
		\item The number of \textit{elements}
	\end{itemize}
\item Optionally, the array can also be initialised
\item The syntax for an array of length N is:\\
\textit{data type} \texttt{name[N]}
\item Examples:
	\begin{itemize}
		\item \texttt{int list[20];}
		\item \texttt{char name[200], c; //array and var}
		\item \texttt{double data[100000];}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Arrays}
\begin{itemize}
\item The length \textbf{must be known at compile time}
\item This won't cause a compile error but will give you \textbf{\textit{BIG PROBLEMS}}:
\begin{lstlisting}[style=CStyle]
int x;
scanf("%d", &x);
int array[x];
\end{lstlisting}
\pause
\begin{itemize}
\item The size of \texttt{array} is not known at compile time
\pause
\item The compiler doesn't know how big it is
\pause
\item If \texttt{x} is large enough your program will access memory the operating system has not allowed it to
\pause
\item This will cause segmentation faults (Linux/macOS) or illegal operations (Windows)
\end{itemize}
\end{itemize}
\end{frame}

\end{document}
