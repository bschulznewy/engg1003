\documentclass[14pt]{beamer}
\usetheme{Dresden}
\usecolortheme{orchid}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm2e}
\usepackage{multicol}

\usefonttheme[onlymath]{serif}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.8,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\definecolor{lightBlue}{rgb}{0.1, 0.1, 0.8}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\lstdefinestyle{Ctable}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\lstdefinestyle{pseudo}{
        basicstyle=\ttfamily\footnotesize,
        keywordstyle=\color{lightBlue},
        morekeywords={BEGIN,END,IF,ELSE,ENDIF,ELSEIF,PRINT,WHILE,RETURN,ENDWHILE,DO,FOR,TO,IN,ENDFOR,BREAK,INPUT},
        morecomment=[l]{//},
        commentstyle=\color{mGreen}
}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt,tabsize=2}

\title{ENGG1003 - Friday Week 2}
\subtitle{Fixing the Mistakes I Made on Tuesday}
\author{Brenton Schulz}
\institute{University of Newcastle}
\date{\today}

\begin{document}
\titlepage

\begin{frame}
Rick is likely presenting this lecture. \\
\vspace{5mm}
My voice was destroyed by being over-enthusiastic while presenting 6 hours of material Monday and Tuesday. Oops.
\end{frame}

\begin{frame}
\frametitle{Example: Testing Factors}
Task: Write a C program which reads two integers from the user and tests if the second is a factor of the first.\\
\vspace{5mm}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example: Testing Factors}
Lets break the problem down into pseudocode:
\begin{lstlisting}[style=pseudo]
BEGIN
	integer x
	integer y
	READ x from the user
	READ y from the user
	Test if x is a factor of y
	Tell the user the result
END
\end{lstlisting}
Can every line of pseudocode be turned into C? How are we going to test if one number is a factor of another?
\end{frame}

\begin{frame}
\frametitle{Example: Testing Factors}
Lets make an attempt at factor testing, perhaps start with:\\
\vspace{5mm}
Definition: \textit{Factors} are numbers we can multiply together to make another number. Eg: 2 and 3 are factors of 6 as $2 \times 3 = 6$.\\
\vspace{5mm}
Is this definition useful for this problem? Is it easy to turn this fact into C code?
\end{frame}

\begin{frame}
\frametitle{Example: Testing Factors}
No, not really. C can't easily do ``can I find another integer that multiplies with $x$ to make $y$''. That instruction is not \textit{executable}. \\
\vspace{5mm}
Lets try again: \\
\vspace{5mm}
An integer, $x$, is a factor of a number, $y$, if the integer evaluation of $y\div x$ has no remainder.\\
\vspace{5mm}
Can \textit{this} become C code?
\end{frame}

\begin{frame}[fragile]
\frametitle{Example: Testing Factors}
YES! We can use the modulus operator, \texttt{\%}, to test if a division has a remainder with the code:

\begin{lstlisting}[style=CStyle]
if( (x % y) == 0) {
	// x is a factor of y
}
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Modulus Example - Factor Testing}
With this fact, lets tweak the pseudocode:
\begin{lstlisting}[style=pseudo]
BEGIN
	integer x
	integer y
	READ x from the user
	READ y from the user
	IF (x % y) == 0
		PRINT x is a factor of y
	ELSE
		PRINT x is NOT a factor of y
	ENDIF
END
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Modulus Example - Factor Testing}
...and convert each line to C:\\
\vspace{4mm}
\small{(\texttt{printf();} output changed to fit on slide)}
\vspace{-2mm}
\begin{table}[H]
\centering

\begin{tabular}{ll}
Pseudocode & C Code \\
\hline

\begin{lstlisting}[style=pseudo,basicstyle=\ttfamily\scriptsize]
BEGIN
	integer x
	integer y
	READ x from the user
	READ y from the user
	IF (x % y) == 0
		PRINT y is a factor
	ELSE
		PRINT y isn't a factor
	ENDIF
END
\end{lstlisting} &

\begin{lstlisting}[style=Ctable,basicstyle=\ttfamily\scriptsize]
int main() {
	int x;
	int y;
	scanf("%d", &x);
	scanf("%d", &y);
	if( (x % y) == 0) {
		printf("%d is a factor\n", y);
	} else {
		printf("%d isn't factor\n", y);
	}
}
\end{lstlisting}
\\

\hline
\end{tabular}
\end{table}

\end{frame}


\begin{frame}[fragile]
\frametitle{Modulus Example - Code with Prompt}
\begin{lstlisting}[style=CStyle,caption=\texttt{factorTest.c}]
#include <stdio.h>
int main() {
	int x, y;
	printf("Enter an integer: ");
	scanf("%d", &x);
	printf("Enter another integer: ");
	scanf("%d", &y);
	if(x % y == 0) { // ie: if the remainder is zero
		printf("%d is a factor of %d\n", y, x);
	} else {
		printf("%d is NOT a factor of %d\n", y, x);
	}
	return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Factor Testing Discussion}
\begin{itemize}
\item Is this code \textit{robust}?
\item Can the user enter numbers which make the code produce the wrong number?
\item What happens if $\texttt{y}>\texttt{x}$?
	\begin{itemize}
		\item It might be fine, it might not. Have a think about it and do some testing in the lab
	\end{itemize}
\item Get in the habit of testing code, both with ``expected'' input and ``weird'' input
\item What happens if you enter letters instead of numbers?
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Modulus Example 2 - Finding Factors}
\begin{itemize}
\item We now know how to test if a number is a factor of another
\item What about a full factorisation?
\end{itemize}

\textbf{Task:} Write a C program which reads an integer from the user and outputs all of its factors.
\end{frame}

\begin{frame}
\frametitle{Modulus Example 2 - Finding Factors}
\begin{itemize}
\item How does factorisation happen, anyway?
	\begin{itemize}
		\item Normally? In your head. ``Dream up'' the answer.
		\item On a computer? We need to \textit{brute force} it.
			\begin{itemize}
				\item ie: Simply test every integer which might work	
			\end{itemize}
		\item All factors of a number, $k$ are in the range [0,k]
		\item They are also all integers
		\item Thankfully, this is a finite number of tests
	\end{itemize}
\item Faster algorithms \textit{might} exist
	\begin{itemize}
		\item You would need to consult number theory literature
		\item This is beyond my (Brenton's) knowledge
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Modulus Example 2 - Finding Factors}
\begin{itemize}
\item How can we test lots of numbers?
	\begin{itemize}
		\item The program needs to count
		\item The input is unknown, so we need a loop
		\item ie: we can't ``hard code'' counting when  we don't know when to stop!
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Modulus Example - Finding Factors}

\begin{lstlisting}[style=CStyle,basicstyle=\ttfamily\footnotesize,caption=\texttt{factors.c}]
#include <stdio.h>
int main() {
	int input, x;
	printf("Enter an integer to factorise: ");
	scanf("%d", &input);
	x = input;
	while(x > 0) {
		if(input % x == 0) // ie: if the remainder is zero
			printf("%d is a factor of %d\n", x, input);
		x--;
	}
	return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{DO ... WHILE}
\begin{itemize}
\item Same as WHILE except executes \textit{at least once}
\item The condition is tested at the end
\item Loops repeats if condition is TRUE
\item Syntax:
\begin{lstlisting}[style=pseudo]
DO
	stuff
WHILE condition
\end{lstlisting}
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{FOR Loops}
\begin{itemize}
\item A FOR loop executes a given number of times
\item Used when the number of loop repeats is known \textit{before} entering the loop
	\begin{itemize}
		\item Repeat count could be ``hard coded'' as a number
		\item Could also be a variable
	\end{itemize}
\item Can be easier to read than WHILE
\item Example pseudocode syntax:
\begin{lstlisting}[style=pseudo]
FOR x = 1 to 10
	Do something ten times
ENDFOR
\end{lstlisting}
\item The \textit{loop variable} is automatically incremented
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{BREAK Statements}
\begin{itemize}
\item Sometimes you want to exit a loop \textit{before} the condition is re-tested
\item The flow-control mechanism for this is a BREAK statement
\item If executed, the loop quits
\item BREAKs typically go inside an IF to control their execution
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Loop \texttt{continue} Statements}
\begin{itemize}
	\item Previously we saw loop \texttt{break} statements
		\begin{itemize}
			\item Caused loop to exit
		\end{itemize}
	\item A \texttt{continue} causes execution to jump back to the loop start
	\item The \textit{condition} is tested before reentry
	
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{FOR Example 1}
\begin{itemize}
\item Two equivalent ways to implement the $\cos()$ series from before are:
\end{itemize}
{\small\textbf{NB:} $|$\texttt{tmp}$|$ means ``absolute value of tmp''.}
\begin{multicols}{2}
\begin{lstlisting}[style=pseudo,mathescape=true,basicstyle=\ttfamily\scriptsize]
BEGIN
	INPUT x
	sum = 0
	FOR k = 0 to 10
		tmp = $\frac{(-1)^k x^{2k}}{(2k)!}$
		sum = sum + tmp
		IF |tmp| < 1e-6
			BREAK
		ENDIF
	ENDWHILE 
END
\end{lstlisting}
\columnbreak
\begin{lstlisting}[style=pseudo,mathescape=true,basicstyle=\ttfamily\scriptsize]
BEGIN
	INPUT x
	tmp = 1
	k = 0
	sum = 0
	WHILE (k<10)AND(|tmp|>1e-6)
		tmp = $\frac{(-1)^k x^{2k}}{(2k)!}$
		sum = sum + tmp
		k = k + 1
	ENDWHILE 
END
\end{lstlisting}

\end{multicols}
\end{frame}

\begin{frame}[fragile]
\frametitle{FOR Example 2 - Factorials}
\begin{itemize}
\item Use FOR to count from 2 to our input number
\item Keep a running product as we go
\begin{lstlisting}[style=pseudo]
BEGIN
	INPUT x
	result = 1
	FOR k = 2 TO x
		result = result * k
	ENDFOR
END
\end{lstlisting}
\item Is this algorithm robust? What happens if:
	\begin{itemize}
		\item x = -1
		\item x = 1
		\item x = 0 (\textbf{NB:} 0! = 1 because \textit{maths})
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{GOTO}
\begin{itemize}
\item There exists a GOTO flow control mechanism
	\begin{itemize}
		\item Sometimes also called a \textit{branch}
	\end{itemize}
\item It ``jumps'' from one line to a different line
\item It exists for a purpose
\item That purpose does not (typically) exist when writing C code
	\begin{itemize}
		\item C \textit{supports} a \texttt{goto} statement
		\item It results in ``spaghetti code'' which is hard to read
		\item Don't use it in ENGG1003
	\end{itemize}
\item You \textit{can} use GOTO in ELEC1710
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Increment Example}
\begin{lstlisting}[style=CStyle,caption=\texttt{increment.c}]
#include <stdio.h>
int main() {
	int x = 0;
	int y = 0;
	int z = 0;
	y = ++x + 10;
	printf("Pre-increment: %d\n", y);
	y = z++ + 10;
	printf("Post-increment: %d\n", y);
	return 0;
}
\end{lstlisting}
Pre/post-inc/decrements have many applications, more details in coming weeks.
\end{frame}

\begin{frame}
\frametitle{Binary Nomenclature}
\begin{itemize}
\item The value range is a result of the underlying binary storage mechanism
\item A single binary digit is called a \textit{bit}
\item There are 8 bits in a \textit{byte}
\item In programming we use the ``power of two'' definitions of kB, MB, etc:
	\begin{itemize}
		\item 1 kilobyte is $2^{10} = 1024$ bytes
		\item 1 Megabyte is $2^{20} = 1048576$ bytes
		\item 1 Gigabyte is $2^{30} = 1073741824$ bytes
		\item (Advanced) These numbers look better in hex: \texttt{0x3FF}, \texttt{0xFFFFF}, etc.
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Binary Nomenclature}
\begin{itemize}
\item Observe that kilobyte, Megabyte, Gigabyte, etc use scientific prefixes
\item These \textit{normally} mean a power of 10:
	\begin{itemize}
		\item kilo- = $10^3$
		\item Mega- = $10^6$
		\item Giga- = $10^9$
		\item ...etc (see the inside cover of a physics text)
	\end{itemize}
\item Computer science stole these terms and re-defined them

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Binary Nomenclature}
\begin{itemize}
\item This has made some people \textit{illogically angry}
\item Instead, we can use a more modern standard:
	\begin{itemize}
		\item $2^{10}$ bytes = 1 kibiByte (KiB)
		\item $2^{20}$ bytes = 1 Mebibyte (MiB)
		\item $2^{30}$ bytes = 1 Gibibyte (GiB)
		\item ...etc
	\end{itemize}
\item Generally speaking, KB (etc) implies:
	\begin{itemize}
		\item powers of two to \textit{engineers}
		\item powers of ten to \textit{marketing}
			\begin{itemize}
				\item The number is smaller
				\item Hard drive manufacturers, ISPs, etc like this
			\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Unambiguous Integer Data Types}
\begin{itemize}
\item Because the standard \texttt{int} and \texttt{long} data types don't have fixed size unambiguous types exist
\item Under OnlineGDB (ie: Linux with \texttt{gcc}) these are defined in \texttt{stdint.h} (\texttt{\#include} it)
\item You will see them used commonly in embedded systems programming (eg: Arduino code)
\item The types are:
	\begin{itemize}
		\item \texttt{int8\_t}
		\item \texttt{uint8\_t}
		\item \texttt{int16\_t}
		\item ...etc
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Code Blocks in C}
\end{frame}

\begin{frame}
\frametitle{Variable Scope}
\end{frame}

\begin{frame}
\frametitle{\#define Constants}
\end{frame}

\begin{frame}
\frametitle{\texttt{for(;;)} Loops}
\end{frame}



\end{document}
