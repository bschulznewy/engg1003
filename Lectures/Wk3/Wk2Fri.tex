\documentclass[14pt]{beamer}
\usetheme{Dresden}
\usecolortheme{orchid}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm2e}
\usepackage{multicol}

\usefonttheme[onlymath]{serif}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.8,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\definecolor{lightBlue}{rgb}{0.1, 0.1, 0.8}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\lstdefinestyle{Ctable}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\lstdefinestyle{pseudo}{
        basicstyle=\ttfamily\footnotesize,
        keywordstyle=\color{lightBlue},
        morekeywords={BEGIN,END,IF,ELSE,ENDIF,ELSEIF,PRINT,WHILE,RETURN,ENDWHILE,DO,FOR,TO,IN,ENDFOR,BREAK,INPUT,READ},
        morecomment=[l]{//},
        commentstyle=\color{mGreen}
}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt,tabsize=2}

\title{ENGG1003 - Friday Week 2}
\subtitle{More Flow Control\\and Examples}
\author{Brenton Schulz}
\institute{University of Newcastle}
\date{\today}

\begin{document}
\titlepage

\begin{frame}[fragile]
\frametitle{DO ... WHILE}
\begin{itemize}
\item Same as WHILE except executes \textit{at least once}
\item The condition is tested at the end
\item Loops repeats if condition is TRUE
\item Pseudocode syntax:
\begin{lstlisting}[style=pseudo]
DO
	stuff
WHILE condition
\end{lstlisting}
\item C syntax:
\begin{lstlisting}[style=CStyle]
do {
	// do stuff
} while(condition)
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{DO ... WHILE}
\begin{itemize}
\item A toy example in C:
\begin{lstlisting}[style=CStyle]
int main() {
	int x = 0;
	do {
		x = x - 1;
	} while(x > 0)
	return 0;
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{DO ... WHILE}
\begin{itemize}
\item A slightly less toy example:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int main() {
	int x;
	do {
		printf("Enter an integer: ");
		scanf("%d", &x);
		if(x%2==0)
			printf("%d is even\n", x);
		else
			printf("%d is odd\n", x);
	} while(x >= 0);
	return 0;
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{DO ... WHILE}
\begin{itemize}
\item \textbf{NB:} The previous example had:
\begin{lstlisting}[style=CStyle]
		if(x%2==0)
			printf("%d is even\n", x);
		else
			printf("%d is odd\n", x);
\end{lstlisting}
\item The \{ \} block is optional if \textit{only one statement} is after an \texttt{if()}, \texttt{while()}, etc
\item I omitted it to reduce line count so that the code would fit on the slide
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{\texttt{do ... while();} is Optional}
\begin{itemize}
	\item It is never \textit{absolutely necessary} to use \texttt{do ... while();}
	\item Sometimes it is easier
	\item eg: Initial value irrelevant with \texttt{do while();}
\end{itemize}
\vspace{-5mm}
\begin{table}[H]
\centering

\begin{tabular}{ll}
\texttt{while()} & \texttt{do while();} \\
\hline

\begin{lstlisting}[style=Ctable,basicstyle=\ttfamily\scriptsize]
int x = 1;
while(x >= 0) {
	printf("Enter an integer: ");
	scanf("%d", &x);
	if(x%2==0)
		printf("%d is even\n", x);
	else
		printf("%d is odd\n", x);
}
\end{lstlisting} &

\begin{lstlisting}[style=Ctable,basicstyle=\ttfamily\scriptsize]
int x;
do {
	printf("Enter an integer: ");
	scanf("%d", &x);
	if(x%2==0)
		printf("%d is even\n", x);
	else
		printf("%d is odd\n", x);
} while(x >= 0);
\end{lstlisting}
\\

\hline
\end{tabular}
\end{table}

\end{frame}

\begin{frame}
\frametitle{Fibonacci Sequence}
\begin{itemize}
\item The \textit{Fibonacci Sequence} is the series of numbers, starting with 0 and 1, where each number is the sum of the two which came before it

\item ie: 0, 1, 1, 2, 3, 5, 8, 12, 21, ...

\item \textbf{Task:} Write a C program which outputs the Fibonacci Sequence for all integers small enough to fit into an \texttt{int}.

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fibonacci Sequence}
\begin{itemize}
\item Lets break this into two problems:
	\begin{enumerate}
		\item Calculate the Fibonacci Sequence
		\item Worry about the stop condition
	\end{enumerate}
\item Always try to break programming problems down into small chunks
\item Real-world problems are too difficult to complete ``all in one go''
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Fibonacci Sequence}
\begin{itemize}
	\item How do we calculate the Fibonacci Sequence?
	\item Note that we need to keep track of \textit{three} numbers:
		\begin{itemize}
			\item The next number
			\item The previous two numbers
		\end{itemize}
	\item I will use these variable names:
		\begin{lstlisting}[style=CStyle]
int xN;		// x N
int xNm1; // N minus 1
int xNm2; // N minus 2
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Fibonacci Sequence}
\begin{itemize}
\item Each time a new number is calculated, what happens to the variables?
\item All 3 variables change, the sequence in which they change is crucial:
	\begin{lstlisting}[style=CStyle]
xN = xNm1 + xNm2; // Calculate next value
xNm2 = xNm1;//Move old values "down the chain"
xNm1 = xN;
\end{lstlisting}
\item Note that the \textit{oldest} value is overwritten first
	\begin{itemize}
		\item It is the one which is no longer needed for calculation
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Fibonacci Sequence}
\begin{itemize}
	\item Lets sketch some pseudocode:
	\begin{lstlisting}[style=pseudo]
BEGIN
	int xNm2 = 0
	int xNm1 = 1
	int xNext
END
	\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{FOR Loops}
\begin{itemize}
\item A FOR loop executes a given number of times
\item Used when the number of loop repeats is known \textit{before} entering the loop
	\begin{itemize}
		\item Repeat count could be ``hard coded'' as a number
		\item Could also be a variable
	\end{itemize}
\item Can be easier to read than WHILE
\item Example pseudocode syntax:
\begin{lstlisting}[style=pseudo]
FOR x = 1 to 10
	Do something ten times
ENDFOR
\end{lstlisting}
\item The \textit{loop variable} is automatically incremented
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{BREAK Statements}
\begin{itemize}
\item Sometimes you want to exit a loop \textit{before} the condition is re-tested
\item The flow-control mechanism for this is a BREAK statement
\item If executed, the loop quits
\item BREAKs typically go inside an IF to control their execution
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Loop \texttt{continue} Statements}
\begin{itemize}
	\item A \texttt{continue} causes execution to jump back to the loop start
	\item The \textit{condition} is tested before reentry	
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{FOR Example 1}
\begin{itemize}
\item Two equivalent ways to implement the $\cos()$ series from before are:
\end{itemize}
{\small\textbf{NB:} $|$\texttt{tmp}$|$ means ``absolute value of tmp''.}
\begin{multicols}{2}
\begin{lstlisting}[style=pseudo,mathescape=true,basicstyle=\ttfamily\scriptsize]
BEGIN
	INPUT x
	sum = 0
	FOR k = 0 to 10
		tmp = $\frac{(-1)^k x^{2k}}{(2k)!}$
		sum = sum + tmp
		IF |tmp| < 1e-6
			BREAK
		ENDIF
	ENDWHILE 
END
\end{lstlisting}
\columnbreak
\begin{lstlisting}[style=pseudo,mathescape=true,basicstyle=\ttfamily\scriptsize]
BEGIN
	INPUT x
	tmp = 1
	k = 0
	sum = 0
	WHILE (k<10)AND(|tmp|>1e-6)
		tmp = $\frac{(-1)^k x^{2k}}{(2k)!}$
		sum = sum + tmp
		k = k + 1
	ENDWHILE 
END
\end{lstlisting}

\end{multicols}
\end{frame}

\begin{frame}[fragile]
\frametitle{FOR Example 2 - Factorials}
\begin{itemize}
\item Use FOR to count from 2 to our input number
\item Keep a running product as we go
\begin{lstlisting}[style=pseudo]
BEGIN
	INPUT x
	result = 1
	FOR k = 2 TO x
		result = result * k
	ENDFOR
END
\end{lstlisting}
\item Is this algorithm robust? What happens if:
	\begin{itemize}
		\item x = -1
		\item x = 1
		\item x = 0 (\textbf{NB:} 0! = 1 because \textit{maths})
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{GOTO}
\begin{itemize}
\item There exists a GOTO flow control mechanism
	\begin{itemize}
		\item Sometimes also called a \textit{branch}
		\item An ability some consider to be unnatural
	\end{itemize}
\item It ``jumps'' from one line to a different line
\item It exists for a purpose
\item That purpose does not (typically) exist when writing C code
	\begin{itemize}
		\item C \textit{supports} a \texttt{goto} statement
		\item It results in ``spaghetti code'' which is hard to read
		\item Don't use it in ENGG1003
	\end{itemize}
\item You \textit{can} use branch instructions in ELEC1710
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Increment Example}
\begin{lstlisting}[style=CStyle,caption=\texttt{increment.c}]
#include <stdio.h>
int main() {
	int x = 0;
	int y = 0;
	int z = 0;
	y = ++x + 10;
	printf("Pre-increment: %d\n", y);
	y = z++ + 10;
	printf("Post-increment: %d\n", y);
	return 0;
}
\end{lstlisting}
Pre/post-inc/decrements have many applications, more details in coming weeks.
\end{frame}

\begin{frame}
\frametitle{Binary Nomenclature}
\begin{itemize}
\item The value range is a result of the underlying binary storage mechanism
\item A single binary digit is called a \textit{bit}
\item There are 8 bits in a \textit{byte}
\item In programming we use the ``power of two'' definitions of kB, MB, etc:
	\begin{itemize}
		\item 1 kilobyte is $2^{10} = 1024$ bytes
		\item 1 Megabyte is $2^{20} = 1048576$ bytes
		\item 1 Gigabyte is $2^{30} = 1073741824$ bytes
		\item (Advanced) These numbers look better in hex: \texttt{0x3FF}, \texttt{0xFFFFF}, etc.
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Binary Nomenclature}
\begin{itemize}
\item Observe that kilobyte, Megabyte, Gigabyte, etc use scientific prefixes
\item These \textit{normally} mean a power of 10:
	\begin{itemize}
		\item kilo- = $10^3$
		\item Mega- = $10^6$
		\item Giga- = $10^9$
		\item ...etc (see the inside cover of a physics text)
	\end{itemize}
\item Computer science stole these terms and re-defined them

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Binary Nomenclature}
\begin{itemize}
\item This has made some people \textit{illogically angry}
\item Instead, we can use a more modern standard:
	\begin{itemize}
		\item $2^{10}$ bytes = 1 kibiByte (KiB)
		\item $2^{20}$ bytes = 1 Mebibyte (MiB)
		\item $2^{30}$ bytes = 1 Gibibyte (GiB)
		\item ...etc
	\end{itemize}
\item Generally speaking, KB (etc) implies:
	\begin{itemize}
		\item powers of two to \textit{engineers}
		\item powers of ten to \textit{marketing}
			\begin{itemize}
				\item The number is smaller
				\item Hard drive manufacturers, ISPs, etc like this
			\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Unambiguous Integer Data Types}
\begin{itemize}
\item Because the standard \texttt{int} and \texttt{long} data types don't have fixed size unambiguous types exist
\item Under OnlineGDB (ie: Linux with \texttt{gcc}) these are defined in \texttt{stdint.h} (\texttt{\#include} it)
\item You will see them used commonly in embedded systems programming (eg: Arduino code)
\item The types are:
	\begin{itemize}
		\item \texttt{int8\_t}
		\item \texttt{uint8\_t}
		\item \texttt{int16\_t}
		\item ...etc
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code Blocks in C}
\begin{itemize}
\item Semi-revision:
\item The curly braces \{ \} encompass a \textit{block}
\item You have used these with \texttt{if()} and \texttt{while()}
\item They define the set of lines executed inside the \texttt{if()} or \texttt{while()}

\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code Blocks in C}
\begin{itemize}
\item You can place blocks anywhere you like
\item Nothing wrong with:
\begin{lstlisting}[style=CStyle]
int main() {
	int x;
	{
		printf("%d\n", x);
	}
	return 0;
}
\end{lstlisting}
\item This just places the \texttt{printf();} inside a block
\item It doesn't do anything useful, but...
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Variable Scope}
\begin{itemize}
\item A variable's ``existence'' is limited to the block where it is declared
	\begin{itemize}
		\item Plus any blocks within that one
	\end{itemize}
\item Example this code won't compile:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
int main() {
	int x = 2;
	if(x == 2) {
		int k;
		k = 2*x;
	}
	printf("%d\n", k);
	return 0;
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Variable Scope}
\begin{itemize}
\item Note that \texttt{k} was declared inside the \texttt{if()}
\item That means that it no longer exists when the \texttt{if()} has finished
\item This generates a compiler error
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\#define Constants}
TODO
\end{frame}

\begin{frame}
\frametitle{\texttt{for(;;)} Loops}
TODO
\end{frame}



\end{document}
