\documentclass[14pt]{beamer}
\usetheme{Dresden}
\usecolortheme{orchid}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm2e}
\usepackage{multicol}
\usepackage{amssymb}

\usefonttheme[onlymath]{serif}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.8,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\definecolor{lightBlue}{rgb}{0.1, 0.1, 0.8}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\lstdefinestyle{Ctable}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\lstdefinestyle{pseudo}{
        basicstyle=\ttfamily\footnotesize,
        keywordstyle=\color{lightBlue},
        morekeywords={BEGIN,END,IF,ELSE,ENDIF,ELSEIF,PRINT,WHILE,RETURN,ENDWHILE,DO,FOR,TO,IN,ENDFOR,BREAK,INPUT,READ},
        morecomment=[l]{//},
        commentstyle=\color{mGreen}
}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt,tabsize=2}

\title{ENGG1003 - Friday Week 5}
\subtitle{Arrays and Functions:\\Together at Last!\\{\tiny{Does anyone even read the title page?}}\\Also: Maybe Strings \& ASCII Codes}
\author{Brenton Schulz}
\institute{University of Newcastle}
\date{\today}


\begin{document}
\titlepage

\begin{frame}
\frametitle{The Story So Far}
\begin{itemize}
\item Course summary:
	\begin{itemize}
		\item Flow control
			\begin{itemize}
				\item \texttt{if()}
				\item \texttt{while()}
				\item \texttt{for()}
				\item \texttt{switch()}
			\end{itemize}
		\item Variables and data types
		\item Functions
		\item Arrays
	\end{itemize}
\item Today: Arrays and functions together
	\begin{itemize}
		\item Subtext: Pointers
	\end{itemize}
\item Today (maybe): Strings
\item Tuesday: File input-output (I/O)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Programming Assignment And Quiz}
\begin{itemize}
\item The programming assignment will use everything from the previous slide
\item The quiz can include everything up to, and including, the Week 5 Tuesday lecture
	\begin{itemize}
		\item Held in Friday 9-10am lecture
			\begin{itemize}
				\item 40 mins: 9:10am - 9:50m
			\end{itemize}
		\item It will be hand written
			\begin{itemize}
				\item Yes, \textit{real paper}
			\end{itemize}
		\item Mix of:
			\begin{itemize}
				\item Multiple choice
				\item Code reading \& analysis
				\item Short code writing (1-3 lines)
			\end{itemize}
		\item You will \textbf{not} be asked to write out a whole program by hand
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Arrays and Functions}
\begin{itemize}
\item On Tuesday:
	\begin{itemize}
		\item Studied arrays
		\item Studied functions
		\item Didn't mix them
	\end{itemize}
\pause
\item There are two ways to pass arrays to functions:
\vspace{-5mm}
	\begin{itemize}
	\pause
		\item Pass an array element, eg:
		\begin{lstlisting}[style=CStyle]
int function(int x);
// ...
int array[12];
// ...
function(array[6]);
\end{lstlisting}
\pause
		\item Give a function a \textit{pointer} to an array
			\begin{itemize}
				\item Ok, lets break this one down a bit...
			\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Arrays and Functions}
\begin{itemize}
\item Firstly: why don't we pass a whole array?
\pause
	\begin{itemize}
		\item Arrays can be \textit{huge}
		\item Passing a whole array \textit{copies} everything
		\item This is a bad idea so C doesn't support it
		\item (Advanced) Arguments are put to the \textit{stack}
			\begin{itemize}
				\item Google stack Vs heap memory allocation for more information. This is beyond ENGG1003.
			\end{itemize}
	\end{itemize}
\pause
\item Instead, C passes a \textit{pointer}
	\begin{itemize}
		\item This is the \textit{memory address} of the array's start
		\pause
		\item In C, \texttt{name} is equivalent to \texttt{\&name[0]}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Arrays in Memory}
\begin{itemize}
\item Review: When we declare an array, eg,
\begin{lstlisting}[style=CStyle]
int x[20];
\end{lstlisting}
the compiler allocates 20*sizeof(int) = 80 bytes to store it
\item The \textit{memory address} of \texttt{x[0]} is some seemingly random number, \texttt{p}
\item \texttt{p} is a \textit{byte} address
\item Other elements are stored in sequential memory addresses:
	\begin{itemize}
		\item The address of \texttt{x[1]} is \texttt{p + 4}
		\item The address of \texttt{x[i]} is \texttt{p + i*4}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Arrays in Memory}
\begin{itemize}
\item Therefore, to access a given element, \texttt{i}, of an array all we need is:
	\begin{itemize}
		\item A pointer, \texttt{p} to the first element
		\item Knowledge of the arrays \textit{data type}
			\begin{itemize}
				\item Specifically, the type's \textit{size}
			\end{itemize}
		\item The calculation result of \texttt{p + i*size}
	\end{itemize}
\pause
\item So that's what we do with functions:
	\begin{itemize}
		\item The function argument is a \textit{pointer} to a \textit{data type}
	\end{itemize}
\pause
\item C syntax:
\begin{lstlisting}[style=CStyle]
return_type function_name(data_type *varName);
\end{lstlisting}
\item Key syntax element: the \texttt{*} character
\pause
\item Inside the function use \texttt{var[i]} syntax
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Key Points}
\begin{itemize}
\item Because arrays are passed via a pointer the function gets \textit{the actual array}
\item Modifying the array in the function modifies the original variable
\item You don't \textit{need} a return value
	\begin{itemize}
		\item In a technically incorrect way: all the array's elements are ``returned''
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Example}
\begin{itemize}
\item Write a function which zeros the first N elements of an array of \texttt{int}s
\begin{itemize}
	\item Function prototype:
	\pause
		\begin{itemize}
			\item \texttt{void zero(int *x, int N);}
		\end{itemize}
	\pause
	\item The value of \texttt{N} is needed because C won't tell you how long an array is \textit{within the context of the function}
		\begin{itemize}
			\item (Advanced) \texttt{sizeof(x)} will just be the size of the pointer -  4, or 8 bytes
		\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example}
\begin{itemize}
\item Function definition:
\begin{lstlisting}[style=CStyle]
// Zeros first N elements of x
void zero(int *x, int N) {
	int i; // Array index loop counter
	for(i = 0; i < N; i++)
		x[i] = 0; // Use array syntax
	return; // Optional
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Other Examples}
\begin{itemize}
\item Lets write and test these live...
\item Write a function which:
	\begin{itemize}	
		\item Returns the sum of an array of length N
		\item Returns the maximum value in an array of length N
		\item Fills an array with integers between two given numbers \texttt{min} and \texttt{max}
			\begin{itemize}
				\item Prototype:\\\texttt{void countArray(int *x,\\\quad \quad \quad \quad int min, int max);}
				\item eg: countArray(x, 10, 15) sets:\\ \texttt{x[] = \{10, 11, 12, 13, 14, 15\}}
			\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Strings}
\begin{itemize}
\item A \textit{string} is the ``data type'' which stores human-readable text
\item C does not have a \texttt{string} data type
	\begin{itemize}
		\item Most newer languages do
	\end{itemize}
\item In C, strings are stored in arrays of type \texttt{char}
	\begin{itemize}
		\item Their ``length'' is defined by a terminating zero
		\item Terminating means it goes after the last character
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{String Syntax}
\begin{itemize}
\item Since C strings are arrays of type \texttt{char} they are declared with normal array syntax:
\begin{lstlisting}[style=CStyle]
char name[200];
\end{lstlisting}
\item The ``size'' of a string is known as the \textit{length}
\item Strings get terminated with a 0
	\begin{itemize}
		\item Ok, technically NULL but its just a zero in memory
		\item Often NULL is written \texttt{\textbackslash 0}
	\end{itemize}
\item The length is the number of bytes from (and including) the ``start'' pointer and the \texttt{\textbackslash 0}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Strings in Memory}
\begin{itemize}
\item Each character is a single byte
\item The terminating NULL is also a single byte
	\begin{itemize}
		\item Be aware of this when declaring array sizes
	\end{itemize}
\item Everything beyond the NULL is ``garbage''
	\begin{itemize}
		\item Doesn't matter what the array size is
	\end{itemize}
\item The string "hello" would be stored as:
\end{itemize}

(Addresses are made up numbers)
\vspace{-5mm}

{\small\texttt{
\begin{table}[H]
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
Address: & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\
\hline
Data: & ?? & h & e & l & l & o & \textbackslash 0 & ??\\
\hline
\end{tabular}
\end{table}
}}
\end{frame}

\begin{frame}[fragile]
\frametitle{Using Strings}
\begin{itemize}
\item String initialisation uses the syntax:
\begin{lstlisting}[style=CStyle]
char str[6] = {'h', 'e', 'l', 'l', 'o', '\0'};
\end{lstlisting}
\pause
\item Terrible, isn't it?
\pause
\item If the string is \textit{constant} you can do this:
\begin{lstlisting}[style=CStyle]
char str[] = "This is a constant string.";
\end{lstlisting}
	\begin{itemize}
		\item Attempting to modify \texttt{str[]} will cause a crash
		\item The compiler automatically inserts the \texttt{\textbackslash 0}
		\item (Advanced) Strings between " and " are stored in the ``program memory'' and can't be modified for security reasons
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Constants}
\begin{itemize}
\item Aside: any variable which must not be modified can be declared \texttt{const}:
\begin{lstlisting}[style=CStyle]
const char str[] = "This is a help message.";
\end{lstlisting}
\item The \texttt{const} keyword causes a compiler error, instead of a segmentation fault, if you try to modify the variable
\item You can do this to any data type, eg:
\begin{lstlisting}[style=CStyle]
const float pi = 3.14159;
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{String Usage}
\begin{itemize}
\item Normally strings are not initialised with \texttt{\{'a', 'b',\}} syntax
\item Command line programs use a lot of constant strings
	\begin{itemize}
		\item Text inside \texttt{printf()} is a constant string
	\end{itemize}
\item Most strings are read from the user or a file
	\begin{itemize}
		\item In embedded systems they also come from communications peripherals like a UART
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{String Format Specifiers}
\begin{itemize}
\item To \texttt{printf()} or \texttt{scanf()} a string use the \texttt{\%s} format specifier
\item Eg:
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
main() {
	char str[] = "Hello world!";
	
	// NB: Passing array pointer to function
	// just uses the array name as argument
	printf("%s\n", str);
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Strings and \texttt{scanf()}}
\begin{itemize}
\item Because an array name is a pointer to the first element \textbf{do not use \&}
\begin{lstlisting}[style=CStyle]
char str[1024];
scanf("%s", str); // NO & SYMBOL
\end{lstlisting}
\pause
\item How much data does \texttt{\%s} read?
\pause
\item Lets test with an example
\begin{lstlisting}[style=CStyle]
#include<stdio.h> 
int main() { 
    char str[1024]; 
    scanf("%s", str); 
    printf("Read: %s\n", str); 
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Strings and \texttt{scanf()}}
\begin{itemize}
\item Experiment results:
	\begin{itemize}
		\item \texttt{\%s} stops at the first whitespace character
		\item It ignores  whitespace
		\item Interpretation: \texttt{\%s} reads a single word or number
	\end{itemize}
\item This changes if more complicated ``pattern matching'' is included in the \texttt{scanf()} argument
	\begin{itemize}
		\item Beyond ENGG1003
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{ASCII Codes}
\begin{itemize}
\item In C, constant letters in code are typed: \texttt{'a'}
\item The single quote indicates that it is a \textit{literal} letter, not a string
\pause
\item But what is \textit{actually} stored? Doesn't \texttt{char} just store a number from -128 to +127?
\pause
\item Yes! The ASCII standard converts ``letters'' to numbers
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{ASCII Codes}
\begin{itemize}
\item The ASCII standard allocates a number to all letters, numbers, punctuation characters, and several ``control'' characters
\item ASCII is used almost everywhere
	\begin{itemize}
		\item The unicode standard UTF-8 is a superset of ASCII
	\end{itemize}
\item Lets check one out \underline{\href{http://asciichart.com/}{here}}
\item Knowledge of ASCII and \texttt{char} processing in C is necessary for Programming Assignment 1
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Char Variables}
\begin{itemize}
\item There are two ways to interpret a \texttt{char} variable:
	\begin{itemize}
		\item As a text character
		\item As a number
	\end{itemize}
\item The \texttt{\%c} format specifier tells \texttt{printf()} and \texttt{scanf()} to convert between ASCII characters and numbers
\item Eg, this will read a character from \texttt{stdin} and store its ASCII value in \texttt{c}:
\begin{lstlisting}[style=CStyle]
char c;
scanf("%c", &c)
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Char Variables}
\begin{itemize}
\item What happens if you enter the number \texttt{5}?
\begin{lstlisting}[style=CStyle]
char c;
scanf("%c", &c)
\end{lstlisting}
\pause
\item It will store the number 53, as that is the ASCII code for '5'
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{ASCII Letters}
\begin{itemize}
\item The project requires you to process text and identify letters
\item The following table shows the numerical values which letters can occupy under the ASCII standard:

\begin{table}[H]
\begin{center}
\begin{tabular}{ll|ll}
A & 65 & a & 97\\
B & 66 & b & 98\\
C & 67 & c & 100\\
... & & ... & \\
Y & 89 & y & 121\\
Z & 90 & z & 122
\end{tabular}
\end{center}
\end{table}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Char Variables}
\begin{itemize}
\item The numerical value of a character can be printed with \texttt{\%d} and a cast:
\begin{lstlisting}[style=CStyle]
char c;
printf("%d", (int)c);
\end{lstlisting}
\item Characters can be used in \textit{arithmetic} without a problem, eg:
\begin{lstlisting}[style=CStyle]
char c;
scanf("%c", c);
c = c - 65;
\end{lstlisting}
\pause

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Char Variables}
\begin{itemize}
\item The code ``\texttt{c = c - 65}'' will convert each letter of the alphabet to a number with the allocation:
\begin{align*}
A&=0\\
B&=1\\
C&=2\\
 ...\\
Z&=25.
\end{align*}
\pause
\vspace{-5mm}
\item You use this in the project
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\texttt{char} Example}
Write a C program which reads a single char from the user and uses it to select from a text-based menu.\\
~\\
\textit{This is useful for Programming Assignment 1}\\
~\\
\pause
\begin{itemize}
\item We should \texttt{printf()} a menu
\item A single character should be read back
\item Use \texttt{switch} to call off the appropriate function
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{\texttt{char} Example}
\begin{itemize}
\item We can print a menu like this:
\begin{lstlisting}[style=CStyle]
printf("Please select an option: \n");
printf("a) Start a new game\n");
printf("b) Load a saved game\n");
printf("c) Options\n");
printf("d) Quit\n\n");
printf("Selection: ");
\end{lstlisting}
\pause
\item And read the user's input with:
\begin{lstlisting}[style=CStyle]
char c;
scanf("%c", &c); // &c, not a string
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{\texttt{char} Example}
\begin{itemize}
\item We need to read user input \textit{at least once}
\item The user could make a mistake
\item Lets use a \texttt{do \{ \} while()}
\pause
\item What would be used in the condition?
\pause
\item \texttt{c} needs to be \texttt{a}, \texttt{b}, \texttt{c}, or \texttt{d} to continue
\pause
\item Couple of options:
	\begin{itemize}
		\item Naive solution:
\begin{lstlisting}[style=CStyle]
while(c != 'a' && c != 'b' && c != 'c' && c != 'd');
\end{lstlisting}
		\item Use knowledge of ASCII codes:
\begin{lstlisting}[style=CStyle]
while(c < 'a' || c > 'd');
\end{lstlisting}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{\texttt{char} Example}
\begin{itemize}
\item Once input is taken lets use \texttt{switch()}:
\begin{lstlisting}[style=CStyle]
switch(c) {
	case 'a': newGame(); break;
	case 'b': loadGame(); break;
	case 'c': options(); break;
	case 'd': quit(); break;
	default: printf("Unknown option %c\nPlease enter a, b, c, or d\n");
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\texttt{char} Example}
\begin{center}
Lets see the full program in Che...
\end{center}
\end{frame}

\end{document}
